import { p as at, a6 as zr, d as Se, o as H, y as je, R as Mr, B as ci, a7 as _r, j as Y, h as J, m as G, I as Br, J as Or, c as ln, a8 as Te, a9 as Tt, aa as Sn, Y as Rr, M as $r, Q as Hr, ab as Lt, U as Pt, X as Vr, P as ze, ac as Ft, O as Nr, ad as jr, ae as di, af as Kr, r as gt, Z as Wr, w as tt, k as ee, F as Xe, D as hi, E as pt, l as Dt, n as fi, t as Be, $ as pi, g as ke, f as Cn, z as ae, ag as nt, q as sn, ah as qr, C as it, _ as It, ai as Yr, aj as Ur, ak as Qr, al as Gr, am as Xr, A as zt, a as En, b as Jr, an as Zr, a0 as Ke, x as oe, ao as mi, H as Je, ap as be, V as An, u as he, v as Ge, aq as Tn, ar as eo, as as to, G as no, a1 as io, a2 as ro, a3 as oo, a4 as ao, a5 as lo } from "./primeicons-BD1Avdx-.js"; function un() { const e = window.location.search, t = new URLSearchParams(e), n = {}; for (const [i, o] of t.entries()) n[i] = o; return n } function bt(e, t) { const n = parseInt(e.slice(1, 3), 16), i = parseInt(e.slice(3, 5), 16), o = parseInt(e.slice(5, 7), 16); return `rgba(${n}, ${i}, ${o}, ${t})` } const so = at({ __name: "float-app", setup(e) { const t = zr(), n = un(); return n.type === "normal" ? t.push({ path: "/note" }) : n.type === "todo" && t.push({ path: "/todo" }), (i, o) => (H(), Se(je(Mr))) } }); var uo = `
    .p-tieredmenu {
        background: dt('tieredmenu.background');
        color: dt('tieredmenu.color');
        border: 1px solid dt('tieredmenu.border.color');
        border-radius: dt('tieredmenu.border.radius');
        min-width: 12.5rem;
    }

    .p-tieredmenu-root-list,
    .p-tieredmenu-submenu {
        margin: 0;
        padding: dt('tieredmenu.list.padding');
        list-style: none;
        outline: 0 none;
        display: flex;
        flex-direction: column;
        gap: dt('tieredmenu.list.gap');
    }

    .p-tieredmenu-submenu {
        position: absolute;
        min-width: 100%;
        z-index: 1;
        background: dt('tieredmenu.background');
        color: dt('tieredmenu.color');
        border: 1px solid dt('tieredmenu.border.color');
        border-radius: dt('tieredmenu.border.radius');
        box-shadow: dt('tieredmenu.shadow');
    }

    .p-tieredmenu-item {
        position: relative;
    }

    .p-tieredmenu-item-content {
        transition:
            background dt('tieredmenu.transition.duration'),
            color dt('tieredmenu.transition.duration');
        border-radius: dt('tieredmenu.item.border.radius');
        color: dt('tieredmenu.item.color');
    }

    .p-tieredmenu-item-link {
        cursor: pointer;
        display: flex;
        align-items: center;
        text-decoration: none;
        overflow: hidden;
        position: relative;
        color: inherit;
        padding: dt('tieredmenu.item.padding');
        gap: dt('tieredmenu.item.gap');
        user-select: none;
        outline: 0 none;
    }

    .p-tieredmenu-item-label {
        line-height: 1;
    }

    .p-tieredmenu-item-icon {
        color: dt('tieredmenu.item.icon.color');
    }

    .p-tieredmenu-submenu-icon {
        color: dt('tieredmenu.submenu.icon.color');
        margin-left: auto;
        font-size: dt('tieredmenu.submenu.icon.size');
        width: dt('tieredmenu.submenu.icon.size');
        height: dt('tieredmenu.submenu.icon.size');
    }

    .p-tieredmenu-submenu-icon:dir(rtl) {
        margin-left: 0;
        margin-right: auto;
    }

    .p-tieredmenu-item.p-focus > .p-tieredmenu-item-content {
        color: dt('tieredmenu.item.focus.color');
        background: dt('tieredmenu.item.focus.background');
    }

    .p-tieredmenu-item.p-focus > .p-tieredmenu-item-content .p-tieredmenu-item-icon {
        color: dt('tieredmenu.item.icon.focus.color');
    }

    .p-tieredmenu-item.p-focus > .p-tieredmenu-item-content .p-tieredmenu-submenu-icon {
        color: dt('tieredmenu.submenu.icon.focus.color');
    }

    .p-tieredmenu-item:not(.p-disabled) > .p-tieredmenu-item-content:hover {
        color: dt('tieredmenu.item.focus.color');
        background: dt('tieredmenu.item.focus.background');
    }

    .p-tieredmenu-item:not(.p-disabled) > .p-tieredmenu-item-content:hover .p-tieredmenu-item-icon {
        color: dt('tieredmenu.item.icon.focus.color');
    }

    .p-tieredmenu-item:not(.p-disabled) > .p-tieredmenu-item-content:hover .p-tieredmenu-submenu-icon {
        color: dt('tieredmenu.submenu.icon.focus.color');
    }

    .p-tieredmenu-item-active > .p-tieredmenu-item-content {
        color: dt('tieredmenu.item.active.color');
        background: dt('tieredmenu.item.active.background');
    }

    .p-tieredmenu-item-active > .p-tieredmenu-item-content .p-tieredmenu-item-icon {
        color: dt('tieredmenu.item.icon.active.color');
    }

    .p-tieredmenu-item-active > .p-tieredmenu-item-content .p-tieredmenu-submenu-icon {
        color: dt('tieredmenu.submenu.icon.active.color');
    }

    .p-tieredmenu-separator {
        border-block-start: 1px solid dt('tieredmenu.separator.border.color');
    }

    .p-tieredmenu-overlay {
        box-shadow: dt('tieredmenu.shadow');
    }

    .p-tieredmenu-enter-from,
    .p-tieredmenu-leave-active {
        opacity: 0;
    }

    .p-tieredmenu-enter-active {
        transition: opacity 250ms;
    }

    .p-tieredmenu-mobile .p-tieredmenu-submenu {
        position: static;
        box-shadow: none;
        border: 0 none;
        padding-inline-start: dt('tieredmenu.submenu.mobile.indent');
        padding-inline-end: 0;
    }

    .p-tieredmenu-mobile .p-tieredmenu-submenu:dir(rtl) {
        padding-inline-start: 0;
        padding-inline-end: dt('tieredmenu.submenu.mobile.indent');
    }

    .p-tieredmenu-mobile .p-tieredmenu-submenu-icon {
        transition: transform 0.2s;
        transform: rotate(90deg);
    }

    .p-tieredmenu-mobile .p-tieredmenu-item-active > .p-tieredmenu-item-content .p-tieredmenu-submenu-icon {
        transform: rotate(-90deg);
    }
`, co = { submenu: function (t) { var n = t.instance, i = t.processedItem; return { display: n.isItemActive(i) ? "flex" : "none" } } }, ho = { root: function (t) { var n = t.props, i = t.instance; return ["p-tieredmenu p-component", { "p-tieredmenu-overlay": n.popup, "p-tieredmenu-mobile": i.queryMatches }] }, start: "p-tieredmenu-start", rootList: "p-tieredmenu-root-list", item: function (t) { var n = t.instance, i = t.processedItem; return ["p-tieredmenu-item", { "p-tieredmenu-item-active": n.isItemActive(i), "p-focus": n.isItemFocused(i), "p-disabled": n.isItemDisabled(i) }] }, itemContent: "p-tieredmenu-item-content", itemLink: "p-tieredmenu-item-link", itemIcon: "p-tieredmenu-item-icon", itemLabel: "p-tieredmenu-item-label", submenuIcon: "p-tieredmenu-submenu-icon", submenu: "p-tieredmenu-submenu", separator: "p-tieredmenu-separator", end: "p-tieredmenu-end" }, fo = ci.extend({ name: "tieredmenu", style: uo, classes: ho, inlineStyles: co }), gi = { name: "AngleRightIcon", extends: _r }; function po(e) { return yo(e) || bo(e) || go(e) || mo() } function mo() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function go(e, t) { if (e) { if (typeof e == "string") return Qt(e, t); var n = {}.toString.call(e).slice(8, -1); return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Qt(e, t) : void 0 } } function bo(e) { if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e) } function yo(e) { if (Array.isArray(e)) return Qt(e) } function Qt(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, i = Array(t); n < t; n++)i[n] = e[n]; return i } function vo(e, t, n, i, o, r) { return H(), Y("svg", G({ width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, e.pti()), po(t[0] || (t[0] = [J("path", { d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z", fill: "currentColor" }, null, -1)])), 16) } gi.render = vo; var ko = { name: "BaseTieredMenu", extends: ln, props: { popup: { type: Boolean, default: !1 }, model: { type: Array, default: null }, appendTo: { type: [String, Object], default: "body" }, breakpoint: { type: String, default: "960px" }, autoZIndex: { type: Boolean, default: !0 }, baseZIndex: { type: Number, default: 0 }, disabled: { type: Boolean, default: !1 }, tabindex: { type: Number, default: 0 }, ariaLabelledby: { type: String, default: null }, ariaLabel: { type: String, default: null } }, style: fo, provide: function () { return { $pcTieredMenu: this, $parentInstance: this } } }, bi = { name: "TieredMenuSub", hostName: "TieredMenu", extends: ln, emits: ["item-click", "item-mouseenter", "item-mousemove"], container: null, props: { menuId: { type: String, default: null }, focusedItemId: { type: String, default: null }, items: { type: Array, default: null }, visible: { type: Boolean, default: !1 }, level: { type: Number, default: 0 }, templates: { type: Object, default: null }, activeItemPath: { type: Object, default: null }, tabindex: { type: Number, default: 0 } }, methods: { getItemId: function (t) { return "".concat(this.menuId, "_").concat(t.key) }, getItemKey: function (t) { return this.getItemId(t) }, getItemProp: function (t, n, i) { return t && t.item ? di(t.item[n], i) : void 0 }, getItemLabel: function (t) { return this.getItemProp(t, "label") }, getItemLabelId: function (t) { return "".concat(this.menuId, "_").concat(t.key, "_label") }, getPTOptions: function (t, n, i) { return this.ptm(i, { context: { item: t.item, index: n, active: this.isItemActive(t), focused: this.isItemFocused(t), disabled: this.isItemDisabled(t) } }) }, isItemActive: function (t) { return this.activeItemPath.some(function (n) { return n.key === t.key }) }, isItemVisible: function (t) { return this.getItemProp(t, "visible") !== !1 }, isItemDisabled: function (t) { return this.getItemProp(t, "disabled") }, isItemFocused: function (t) { return this.focusedItemId === this.getItemId(t) }, isItemGroup: function (t) { return Te(t.items) }, onEnter: function () { Kr(this.container, this.level) }, onItemClick: function (t, n) { this.getItemProp(n, "command", { originalEvent: t, item: n.item }), this.$emit("item-click", { originalEvent: t, processedItem: n, isFocus: !0 }) }, onItemMouseEnter: function (t, n) { this.$emit("item-mouseenter", { originalEvent: t, processedItem: n }) }, onItemMouseMove: function (t, n) { this.$emit("item-mousemove", { originalEvent: t, processedItem: n }) }, getAriaSetSize: function () { var t = this; return this.items.filter(function (n) { return t.isItemVisible(n) && !t.getItemProp(n, "separator") }).length }, getAriaPosInset: function (t) { var n = this; return t - this.items.slice(0, t).filter(function (i) { return n.isItemVisible(i) && n.getItemProp(i, "separator") }).length + 1 }, getMenuItemProps: function (t, n) { return { action: G({ class: this.cx("itemLink"), tabindex: -1 }, this.getPTOptions(t, n, "itemLink")), icon: G({ class: [this.cx("itemIcon"), this.getItemProp(t, "icon")] }, this.getPTOptions(t, n, "itemIcon")), label: G({ class: this.cx("itemLabel") }, this.getPTOptions(t, n, "itemLabel")), submenuicon: G({ class: this.cx("submenuIcon") }, this.getPTOptions(t, n, "submenuIcon")) } }, containerRef: function (t) { this.container = t } }, components: { AngleRightIcon: gi }, directives: { ripple: Or } }, wo = ["tabindex"], xo = ["id", "aria-label", "aria-disabled", "aria-expanded", "aria-haspopup", "aria-level", "aria-setsize", "aria-posinset", "data-p-active", "data-p-focused", "data-p-disabled"], Io = ["onClick", "onMouseenter", "onMousemove"], So = ["href", "target"], Co = ["id"], Eo = ["id"]; function Ao(e, t, n, i, o, r) { var a = gt("AngleRightIcon"), l = gt("TieredMenuSub", !0), u = Wr("ripple"); return H(), Se(pi, G({ name: "p-tieredmenu", onEnter: r.onEnter }, e.ptm("menu.transition")), { default: tt(function () { return [n.level === 0 || n.visible ? (H(), Y("ul", { key: 0, ref: r.containerRef, tabindex: n.tabindex }, [(H(!0), Y(Xe, null, hi(n.items, function (s, c) { return H(), Y(Xe, { key: r.getItemKey(s) }, [r.isItemVisible(s) && !r.getItemProp(s, "separator") ? (H(), Y("li", G({ key: 0, id: r.getItemId(s), style: r.getItemProp(s, "style"), class: [e.cx("item", { processedItem: s }), r.getItemProp(s, "class")], role: "menuitem", "aria-label": r.getItemLabel(s), "aria-disabled": r.isItemDisabled(s) || void 0, "aria-expanded": r.isItemGroup(s) ? r.isItemActive(s) : void 0, "aria-haspopup": r.isItemGroup(s) && !r.getItemProp(s, "to") ? "menu" : void 0, "aria-level": n.level + 1, "aria-setsize": r.getAriaSetSize(), "aria-posinset": r.getAriaPosInset(c) }, { ref_for: !0 }, r.getPTOptions(s, c, "item"), { "data-p-active": r.isItemActive(s), "data-p-focused": r.isItemFocused(s), "data-p-disabled": r.isItemDisabled(s) }), [J("div", G({ class: e.cx("itemContent"), onClick: function (f) { return r.onItemClick(f, s) }, onMouseenter: function (f) { return r.onItemMouseEnter(f, s) }, onMousemove: function (f) { return r.onItemMouseMove(f, s) } }, { ref_for: !0 }, r.getPTOptions(s, c, "itemContent")), [n.templates.item ? (H(), Se(Dt(n.templates.item), { key: 1, item: s.item, hasSubmenu: r.getItemProp(s, "items"), label: r.getItemLabel(s), props: r.getMenuItemProps(s, c) }, null, 8, ["item", "hasSubmenu", "label", "props"])) : pt((H(), Y("a", G({ key: 0, href: r.getItemProp(s, "url"), class: e.cx("itemLink"), target: r.getItemProp(s, "target"), tabindex: "-1" }, { ref_for: !0 }, r.getPTOptions(s, c, "itemLink")), [n.templates.itemicon ? (H(), Se(Dt(n.templates.itemicon), { key: 0, item: s.item, class: fi(e.cx("itemIcon")) }, null, 8, ["item", "class"])) : r.getItemProp(s, "icon") ? (H(), Y("span", G({ key: 1, class: [e.cx("itemIcon"), r.getItemProp(s, "icon")] }, { ref_for: !0 }, r.getPTOptions(s, c, "itemIcon")), null, 16)) : ee("", !0), J("span", G({ id: r.getItemLabelId(s), class: e.cx("itemLabel") }, { ref_for: !0 }, r.getPTOptions(s, c, "itemLabel")), Be(r.getItemLabel(s)), 17, Co), r.getItemProp(s, "items") ? (H(), Y(Xe, { key: 2 }, [n.templates.submenuicon ? (H(), Se(Dt(n.templates.submenuicon), G({ key: 0, class: e.cx("submenuIcon"), active: r.isItemActive(s) }, { ref_for: !0 }, r.getPTOptions(s, c, "submenuIcon")), null, 16, ["class", "active"])) : (H(), Se(a, G({ key: 1, class: e.cx("submenuIcon") }, { ref_for: !0 }, r.getPTOptions(s, c, "submenuIcon")), null, 16, ["class"]))], 64)) : ee("", !0)], 16, So)), [[u]])], 16, Io), r.isItemVisible(s) && r.isItemGroup(s) ? (H(), Se(l, G({ key: 0, id: r.getItemId(s) + "_list", class: e.cx("submenu"), style: e.sx("submenu", !0, { processedItem: s }), "aria-labelledby": r.getItemLabelId(s), role: "menu", menuId: n.menuId, focusedItemId: n.focusedItemId, items: s.items, templates: n.templates, activeItemPath: n.activeItemPath, level: n.level + 1, visible: r.isItemActive(s) && r.isItemGroup(s), pt: e.pt, unstyled: e.unstyled, onItemClick: t[0] || (t[0] = function (d) { return e.$emit("item-click", d) }), onItemMouseenter: t[1] || (t[1] = function (d) { return e.$emit("item-mouseenter", d) }), onItemMousemove: t[2] || (t[2] = function (d) { return e.$emit("item-mousemove", d) }) }, { ref_for: !0 }, e.ptm("submenu")), null, 16, ["id", "class", "style", "aria-labelledby", "menuId", "focusedItemId", "items", "templates", "activeItemPath", "level", "visible", "pt", "unstyled"])) : ee("", !0)], 16, xo)) : ee("", !0), r.isItemVisible(s) && r.getItemProp(s, "separator") ? (H(), Y("li", G({ key: 1, id: r.getItemId(s), style: r.getItemProp(s, "style"), class: [e.cx("separator"), r.getItemProp(s, "class")], role: "separator" }, { ref_for: !0 }, e.ptm("separator")), null, 16, Eo)) : ee("", !0)], 64) }), 128))], 8, wo)) : ee("", !0)] }), _: 1 }, 16, ["onEnter"]) } bi.render = Ao; var yi = { name: "TieredMenu", extends: ko, inheritAttrs: !1, emits: ["focus", "blur", "before-show", "before-hide", "hide", "show"], outsideClickListener: null, matchMediaListener: null, scrollHandler: null, resizeListener: null, target: null, container: null, menubar: null, searchTimeout: null, searchValue: null, data: function () { return { focused: !1, focusedItemInfo: { index: -1, level: 0, parentKey: "" }, activeItemPath: [], visible: !this.popup, submenuVisible: !1, dirty: !1, query: null, queryMatches: !1 } }, watch: { activeItemPath: function (t) { this.popup || (Te(t) ? (this.bindOutsideClickListener(), this.bindResizeListener()) : (this.unbindOutsideClickListener(), this.unbindResizeListener())) } }, mounted: function () { this.bindMatchMediaListener() }, beforeUnmount: function () { this.unbindOutsideClickListener(), this.unbindResizeListener(), this.unbindMatchMediaListener(), this.scrollHandler && (this.scrollHandler.destroy(), this.scrollHandler = null), this.container && this.autoZIndex && Pt.clear(this.container), this.target = null, this.container = null }, methods: { getItemProp: function (t, n) { return t ? di(t[n]) : void 0 }, getItemLabel: function (t) { return this.getItemProp(t, "label") }, isItemDisabled: function (t) { return this.getItemProp(t, "disabled") }, isItemVisible: function (t) { return this.getItemProp(t, "visible") !== !1 }, isItemGroup: function (t) { return Te(this.getItemProp(t, "items")) }, isItemSeparator: function (t) { return this.getItemProp(t, "separator") }, getProccessedItemLabel: function (t) { return t ? this.getItemLabel(t.item) : void 0 }, isProccessedItemGroup: function (t) { return t && Te(t.items) }, toggle: function (t) { this.visible ? this.hide(t, !0) : this.show(t) }, show: function (t, n) { this.popup && (this.$emit("before-show"), this.visible = !0, this.target = this.target || t.currentTarget, this.relatedTarget = t.relatedTarget || null), n && ze(this.menubar) }, hide: function (t, n) { this.popup && (this.$emit("before-hide"), this.visible = !1), this.activeItemPath = [], this.focusedItemInfo = { index: -1, level: 0, parentKey: "" }, n && ze(this.relatedTarget || this.target || this.menubar), this.dirty = !1 }, onFocus: function (t) { this.focused = !0, this.popup || (this.focusedItemInfo = this.focusedItemInfo.index !== -1 ? this.focusedItemInfo : { index: this.findFirstFocusedItemIndex(), level: 0, parentKey: "" }), this.$emit("focus", t) }, onBlur: function (t) { this.focused = !1, this.focusedItemInfo = { index: -1, level: 0, parentKey: "" }, this.searchValue = "", this.dirty = !1, this.$emit("blur", t) }, onKeyDown: function (t) { if (this.disabled) { t.preventDefault(); return } var n = t.metaKey || t.ctrlKey; switch (t.code) { case "ArrowDown": this.onArrowDownKey(t); break; case "ArrowUp": this.onArrowUpKey(t); break; case "ArrowLeft": this.onArrowLeftKey(t); break; case "ArrowRight": this.onArrowRightKey(t); break; case "Home": this.onHomeKey(t); break; case "End": this.onEndKey(t); break; case "Space": this.onSpaceKey(t); break; case "Enter": case "NumpadEnter": this.onEnterKey(t); break; case "Escape": this.onEscapeKey(t); break; case "Tab": this.onTabKey(t); break; case "PageDown": case "PageUp": case "Backspace": case "ShiftLeft": case "ShiftRight": break; default: !n && jr(t.key) && this.searchItems(t, t.key); break } }, onItemChange: function (t, n) { var i = t.processedItem, o = t.isFocus; if (!Ft(i)) { var r = i.index, a = i.key, l = i.level, u = i.parentKey, s = i.items, c = Te(s), d = this.activeItemPath.filter(function (f) { return f.parentKey !== u && f.parentKey !== a }); c && (d.push(i), this.submenuVisible = !0), this.focusedItemInfo = { index: r, level: l, parentKey: u }, c && (this.dirty = !0), o && ze(this.menubar), !(n === "hover" && this.queryMatches) && (this.activeItemPath = d) } }, onOverlayClick: function (t) { Nr.emit("overlay-click", { originalEvent: t, target: this.target }) }, onItemClick: function (t) { var n = t.originalEvent, i = t.processedItem, o = this.isProccessedItemGroup(i), r = Ft(i.parent), a = this.isSelected(i); if (a) { var l = i.index, u = i.key, s = i.level, c = i.parentKey; this.activeItemPath = this.activeItemPath.filter(function (f) { return u !== f.key && u.startsWith(f.key) }), this.focusedItemInfo = { index: l, level: s, parentKey: c }, this.dirty = !r, ze(this.menubar) } else if (o) this.onItemChange(t); else { var d = r ? i : this.activeItemPath.find(function (f) { return f.parentKey === "" }); this.hide(n), this.changeFocusedItemIndex(n, d ? d.index : -1), ze(this.menubar) } }, onItemMouseEnter: function (t) { this.dirty && this.onItemChange(t, "hover") }, onItemMouseMove: function (t) { this.focused && this.changeFocusedItemIndex(t, t.processedItem.index) }, onArrowDownKey: function (t) { var n = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex(); this.changeFocusedItemIndex(t, n), t.preventDefault() }, onArrowUpKey: function (t) { if (t.altKey) { if (this.focusedItemInfo.index !== -1) { var n = this.visibleItems[this.focusedItemInfo.index], i = this.isProccessedItemGroup(n); !i && this.onItemChange({ originalEvent: t, processedItem: n }) } this.popup && this.hide(t, !0), t.preventDefault() } else { var o = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex(); this.changeFocusedItemIndex(t, o), t.preventDefault() } }, onArrowLeftKey: function (t) { var n = this, i = this.visibleItems[this.focusedItemInfo.index], o = this.activeItemPath.find(function (a) { return a.key === i.parentKey }), r = Ft(i.parent); r || (this.focusedItemInfo = { index: -1, parentKey: o ? o.parentKey : "" }, this.searchValue = "", this.onArrowDownKey(t)), this.activeItemPath = this.activeItemPath.filter(function (a) { return a.parentKey !== n.focusedItemInfo.parentKey }), t.preventDefault() }, onArrowRightKey: function (t) { var n = this.visibleItems[this.focusedItemInfo.index], i = this.isProccessedItemGroup(n); i && (this.onItemChange({ originalEvent: t, processedItem: n }), this.focusedItemInfo = { index: -1, parentKey: n.key }, this.searchValue = "", this.onArrowDownKey(t)), t.preventDefault() }, onHomeKey: function (t) { this.changeFocusedItemIndex(t, this.findFirstItemIndex()), t.preventDefault() }, onEndKey: function (t) { this.changeFocusedItemIndex(t, this.findLastItemIndex()), t.preventDefault() }, onEnterKey: function (t) { if (this.focusedItemInfo.index !== -1) { var n = Tt(this.menubar, 'li[id="'.concat("".concat(this.focusedItemId), '"]')), i = n && Tt(n, '[data-pc-section="itemlink"]'); if (i ? i.click() : n && n.click(), !this.popup) { var o = this.visibleItems[this.focusedItemInfo.index], r = this.isProccessedItemGroup(o); !r && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex()) } } t.preventDefault() }, onSpaceKey: function (t) { this.onEnterKey(t) }, onEscapeKey: function (t) { if (this.popup || this.focusedItemInfo.level !== 0) { var n = this.focusedItemInfo; this.hide(t, !1), this.focusedItemInfo = { index: Number(n.parentKey.split("_")[0]), level: 0, parentKey: "" }, this.popup && ze(this.target) } t.preventDefault() }, onTabKey: function (t) { if (this.focusedItemInfo.index !== -1) { var n = this.visibleItems[this.focusedItemInfo.index], i = this.isProccessedItemGroup(n); !i && this.onItemChange({ originalEvent: t, processedItem: n }) } this.hide() }, onEnter: function (t) { this.autoZIndex && Pt.set("menu", t, this.baseZIndex + this.$primevue.config.zIndex.menu), Vr(t, { position: "absolute", top: "0" }), this.alignOverlay(), ze(this.menubar), this.scrollInView() }, onAfterEnter: function () { this.bindOutsideClickListener(), this.bindScrollListener(), this.bindResizeListener(), this.$emit("show") }, onLeave: function () { this.unbindOutsideClickListener(), this.unbindScrollListener(), this.unbindResizeListener(), this.$emit("hide"), this.container = null, this.dirty = !1 }, onAfterLeave: function (t) { this.autoZIndex && Pt.clear(t) }, alignOverlay: function () { Hr(this.container, this.target); var t = Lt(this.target); t > Lt(this.container) && (this.container.style.minWidth = Lt(this.target) + "px") }, bindOutsideClickListener: function () { var t = this; this.outsideClickListener || (this.outsideClickListener = function (n) { var i = t.container && !t.container.contains(n.target), o = t.popup ? !(t.target && (t.target === n.target || t.target.contains(n.target))) : !0; i && o && t.hide() }, document.addEventListener("click", this.outsideClickListener, !0)) }, unbindOutsideClickListener: function () { this.outsideClickListener && (document.removeEventListener("click", this.outsideClickListener, !0), this.outsideClickListener = null) }, bindScrollListener: function () { var t = this; this.scrollHandler || (this.scrollHandler = new $r(this.target, function (n) { t.hide(n, !0) })), this.scrollHandler.bindScrollListener() }, unbindScrollListener: function () { this.scrollHandler && this.scrollHandler.unbindScrollListener() }, bindResizeListener: function () { var t = this; this.resizeListener || (this.resizeListener = function (n) { Rr() || t.hide(n, !0) }, window.addEventListener("resize", this.resizeListener)) }, unbindResizeListener: function () { this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null) }, bindMatchMediaListener: function () { var t = this; if (!this.matchMediaListener) { var n = matchMedia("(max-width: ".concat(this.breakpoint, ")")); this.query = n, this.queryMatches = n.matches, this.matchMediaListener = function () { t.queryMatches = n.matches }, this.query.addEventListener("change", this.matchMediaListener) } }, unbindMatchMediaListener: function () { this.matchMediaListener && (this.query.removeEventListener("change", this.matchMediaListener), this.matchMediaListener = null) }, isItemMatched: function (t) { var n; return this.isValidItem(t) && ((n = this.getProccessedItemLabel(t)) === null || n === void 0 ? void 0 : n.toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase())) }, isValidItem: function (t) { return !!t && !this.isItemDisabled(t.item) && !this.isItemSeparator(t.item) && this.isItemVisible(t.item) }, isValidSelectedItem: function (t) { return this.isValidItem(t) && this.isSelected(t) }, isSelected: function (t) { return this.activeItemPath.some(function (n) { return n.key === t.key }) }, findFirstItemIndex: function () { var t = this; return this.visibleItems.findIndex(function (n) { return t.isValidItem(n) }) }, findLastItemIndex: function () { var t = this; return Sn(this.visibleItems, function (n) { return t.isValidItem(n) }) }, findNextItemIndex: function (t) { var n = this, i = t < this.visibleItems.length - 1 ? this.visibleItems.slice(t + 1).findIndex(function (o) { return n.isValidItem(o) }) : -1; return i > -1 ? i + t + 1 : t }, findPrevItemIndex: function (t) { var n = this, i = t > 0 ? Sn(this.visibleItems.slice(0, t), function (o) { return n.isValidItem(o) }) : -1; return i > -1 ? i : t }, findSelectedItemIndex: function () { var t = this; return this.visibleItems.findIndex(function (n) { return t.isValidSelectedItem(n) }) }, findFirstFocusedItemIndex: function () { var t = this.findSelectedItemIndex(); return t < 0 ? this.findFirstItemIndex() : t }, findLastFocusedItemIndex: function () { var t = this.findSelectedItemIndex(); return t < 0 ? this.findLastItemIndex() : t }, searchItems: function (t, n) { var i = this; this.searchValue = (this.searchValue || "") + n; var o = -1, r = !1; return this.focusedItemInfo.index !== -1 ? (o = this.visibleItems.slice(this.focusedItemInfo.index).findIndex(function (a) { return i.isItemMatched(a) }), o = o === -1 ? this.visibleItems.slice(0, this.focusedItemInfo.index).findIndex(function (a) { return i.isItemMatched(a) }) : o + this.focusedItemInfo.index) : o = this.visibleItems.findIndex(function (a) { return i.isItemMatched(a) }), o !== -1 && (r = !0), o === -1 && this.focusedItemInfo.index === -1 && (o = this.findFirstFocusedItemIndex()), o !== -1 && this.changeFocusedItemIndex(t, o), this.searchTimeout && clearTimeout(this.searchTimeout), this.searchTimeout = setTimeout(function () { i.searchValue = "", i.searchTimeout = null }, 500), r }, changeFocusedItemIndex: function (t, n) { this.focusedItemInfo.index !== n && (this.focusedItemInfo.index = n, this.scrollInView()) }, scrollInView: function () { var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1, n = t !== -1 ? "".concat(this.$id, "_").concat(t) : this.focusedItemId, i = Tt(this.menubar, 'li[id="'.concat(n, '"]')); i && i.scrollIntoView && i.scrollIntoView({ block: "nearest", inline: "start" }) }, createProcessedItems: function (t) { var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "", a = []; return t && t.forEach(function (l, u) { var s = (r !== "" ? r + "_" : "") + u, c = { item: l, index: u, level: i, key: s, parent: o, parentKey: r }; c.items = n.createProcessedItems(l.items, i + 1, c, s), a.push(c) }), a }, containerRef: function (t) { this.container = t }, menubarRef: function (t) { this.menubar = t ? t.$el : void 0 } }, computed: { processedItems: function () { return this.createProcessedItems(this.model || []) }, visibleItems: function () { var t = this, n = this.activeItemPath.find(function (i) { return i.key === t.focusedItemInfo.parentKey }); return n ? n.items : this.processedItems }, focusedItemId: function () { return this.focusedItemInfo.index !== -1 ? "".concat(this.$id).concat(Te(this.focusedItemInfo.parentKey) ? "_" + this.focusedItemInfo.parentKey : "", "_").concat(this.focusedItemInfo.index) : null } }, components: { TieredMenuSub: bi, Portal: Br } }, To = ["id"]; function Lo(e, t, n, i, o, r) { var a = gt("TieredMenuSub"), l = gt("Portal"); return H(), Se(l, { appendTo: e.appendTo, disabled: !e.popup }, { default: tt(function () { return [ke(pi, G({ name: "p-connected-overlay", onEnter: r.onEnter, onAfterEnter: r.onAfterEnter, onLeave: r.onLeave, onAfterLeave: r.onAfterLeave }, e.ptm("transition")), { default: tt(function () { return [o.visible ? (H(), Y("div", G({ key: 0, ref: r.containerRef, id: e.$id, class: e.cx("root"), onClick: t[0] || (t[0] = function () { return r.onOverlayClick && r.onOverlayClick.apply(r, arguments) }) }, e.ptmi("root")), [e.$slots.start ? (H(), Y("div", G({ key: 0, class: e.cx("start") }, e.ptm("start")), [Cn(e.$slots, "start")], 16)) : ee("", !0), ke(a, G({ ref: r.menubarRef, id: e.$id + "_list", class: e.cx("rootList"), tabindex: e.disabled ? -1 : e.tabindex, role: "menubar", "aria-label": e.ariaLabel, "aria-labelledby": e.ariaLabelledby, "aria-disabled": e.disabled || void 0, "aria-orientation": "vertical", "aria-activedescendant": o.focused ? r.focusedItemId : void 0, menuId: e.$id, focusedItemId: o.focused ? r.focusedItemId : void 0, items: r.processedItems, templates: e.$slots, activeItemPath: o.activeItemPath, level: 0, visible: o.submenuVisible, pt: e.pt, unstyled: e.unstyled, onFocus: r.onFocus, onBlur: r.onBlur, onKeydown: r.onKeyDown, onItemClick: r.onItemClick, onItemMouseenter: r.onItemMouseEnter, onItemMousemove: r.onItemMouseMove }, e.ptm("rootList")), null, 16, ["id", "class", "tabindex", "aria-label", "aria-labelledby", "aria-disabled", "aria-activedescendant", "menuId", "focusedItemId", "items", "templates", "activeItemPath", "visible", "pt", "unstyled", "onFocus", "onBlur", "onKeydown", "onItemClick", "onItemMouseenter", "onItemMousemove"]), e.$slots.end ? (H(), Y("div", G({ key: 1, class: e.cx("end") }, e.ptm("end")), [Cn(e.$slots, "end")], 16)) : ee("", !0)], 16, To)) : ee("", !0)] }), _: 3 }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])] }), _: 3 }, 8, ["appendTo", "disabled"]) } yi.render = Lo; const Po = { key: 0, class: "input-status" }, Fo = { id: "moreBtn", class: "btns" }, Do = ["onClick"], zo = { class: "menu-label" }, Mo = { key: 2, class: "shortcut" }, _o = { key: 3, class: "pi pi-angle-right" }, Bo = at({ __name: "window-header", props: { isEditing: { type: Boolean, default: !1 }, isAlwaysOnTop: { type: Boolean, default: !0 }, background: { default: "" }, showEditSaveMenu: { type: Boolean, default: !0 } }, emits: ["close", "save", "edit", "changeBg", "openOpacitySetting", "changeAlwaysOnTop"], setup(e, { emit: t }) { const n = e, i = t, o = ae(), r = ae("⌘"), a = nt(() => { const c = [{ icon: "pi pi-palette", label: "背景", items: [{ label: "绿色", color: "#c1f3bd", value: "#c1f3bd" }, { label: "紫色", color: "#d3bdf3", value: "#d3bdf3" }, { label: "红色", color: "#f3cbbd", value: "#f3cbbd" }, { label: "蓝色", color: "#bdd7f3", value: "#bdd7f3" }, { label: "黄色", color: "#f3f0bd", value: "#f3f0bd" }] }, { icon: "pi pi-thumbtack", label: n.isAlwaysOnTop ? "取消置顶" : "置顶", value: "top" }, { icon: "pi pi-sun", label: "透明度", value: "opacity" }]; return n.showEditSaveMenu && c.push({ icon: n.isEditing ? "pi pi-save" : "pi pi-pencil", label: n.isEditing ? "保存" : "编辑", value: n.isEditing ? "save" : "edit" }), c.push({ icon: "pi pi-times", label: "关闭", value: "close" }), c }); sn(() => { typeof ztools < "u" && (ztools.isWindows() ? r.value = "Ctl" : r.value = "⌘"), document.addEventListener("keydown", u) }), qr(() => { document.removeEventListener("keydown", u) }); const l = c => { o.value.toggle(c) }; function u(c) { (c.ctrlKey || c.metaKey) && c.key === "s" && (c.preventDefault(), i("save")) } function s(c) { console.log(c), c.value === "close" ? i("close") : c.value === "edit" ? i("edit") : c.value === "save" ? i("save") : c.color && c.value && c.value.startsWith("#") ? i("changeBg", c.value) : c.value === "opacity" ? i("openOpacitySetting") : c.value === "top" && i("changeAlwaysOnTop", !n.isAlwaysOnTop) } return (c, d) => (H(), Y("div", { id: "windowHeader", class: "window-header", style: it({ background: e.background }) }, [e.isEditing ? (H(), Y("div", Po, Be(r.value) + "+S 保存", 1)) : ee("", !0), J("div", Fo, [J("div", { class: "btn", "aria-haspopup": "true", "aria-controls": "overlay_tmenu", onClick: l }, [...d[0] || (d[0] = [J("i", { class: "pi pi-ellipsis-v" }, null, -1)])]), ke(je(yi), { ref_key: "menuRef", ref: o, id: "overlay_tmenu", model: a.value, popup: "", breakpoint: "0" }, { item: tt(({ item: f, props: h, hasSubmenu: g }) => [J("a", G({ class: "menu-a" }, h.action, { onClick: k => s(f) }), [f.color ? (H(), Y("div", { key: 0, class: "bg-box", style: it({ background: f.color }) }, null, 4)) : ee("", !0), f.icon ? (H(), Y("span", { key: 1, class: fi(f.icon) }, null, 2)) : ee("", !0), J("span", zo, Be(f.label), 1), f.shortcut ? (H(), Y("span", Mo, Be(f.shortcut), 1)) : ee("", !0), g ? (H(), Y("i", _o)) : ee("", !0)], 16, Do)]), _: 1 }, 8, ["model"])])], 4)) } }), vi = It(Bo, [["__scopeId", "data-v-9c943059"]]); var Oo = { name: "BaseEditableHolder", extends: ln, emits: ["update:modelValue", "value-change"], props: { modelValue: { type: null, default: void 0 }, defaultValue: { type: null, default: void 0 }, name: { type: String, default: void 0 }, invalid: { type: Boolean, default: void 0 }, disabled: { type: Boolean, default: !1 }, formControl: { type: Object, default: void 0 } }, inject: { $parentInstance: { default: void 0 }, $pcForm: { default: void 0 }, $pcFormField: { default: void 0 } }, data: function () { return { d_value: this.defaultValue !== void 0 ? this.defaultValue : this.modelValue } }, watch: { modelValue: function (t) { this.d_value = t }, defaultValue: function (t) { this.d_value = t }, $formName: { immediate: !0, handler: function (t) { var n, i; this.formField = ((n = this.$pcForm) === null || n === void 0 || (i = n.register) === null || i === void 0 ? void 0 : i.call(n, t, this.$formControl)) || {} } }, $formControl: { immediate: !0, handler: function (t) { var n, i; this.formField = ((n = this.$pcForm) === null || n === void 0 || (i = n.register) === null || i === void 0 ? void 0 : i.call(n, this.$formName, t)) || {} } }, $formDefaultValue: { immediate: !0, handler: function (t) { this.d_value !== t && (this.d_value = t) } }, $formValue: { immediate: !1, handler: function (t) { var n; (n = this.$pcForm) !== null && n !== void 0 && n.getFieldState(this.$formName) && t !== this.d_value && (this.d_value = t) } } }, formField: {}, methods: { writeValue: function (t, n) { var i, o; this.controlled && (this.d_value = t, this.$emit("update:modelValue", t)), this.$emit("value-change", t), (i = (o = this.formField).onChange) === null || i === void 0 || i.call(o, { originalEvent: n, value: t }) }, findNonEmpty: function () { for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return n.find(Te) } }, computed: { $filled: function () { return Te(this.d_value) }, $invalid: function () { var t, n; return !this.$formNovalidate && this.findNonEmpty(this.invalid, (t = this.$pcFormField) === null || t === void 0 || (t = t.$field) === null || t === void 0 ? void 0 : t.invalid, (n = this.$pcForm) === null || n === void 0 || (n = n.getFieldState(this.$formName)) === null || n === void 0 ? void 0 : n.invalid) }, $formName: function () { var t; return this.$formNovalidate ? void 0 : this.name || ((t = this.$formControl) === null || t === void 0 ? void 0 : t.name) }, $formControl: function () { var t; return this.formControl || ((t = this.$pcFormField) === null || t === void 0 ? void 0 : t.formControl) }, $formNovalidate: function () { var t; return (t = this.$formControl) === null || t === void 0 ? void 0 : t.novalidate }, $formDefaultValue: function () { var t, n; return this.findNonEmpty(this.d_value, (t = this.$pcFormField) === null || t === void 0 ? void 0 : t.initialValue, (n = this.$pcForm) === null || n === void 0 || (n = n.initialValues) === null || n === void 0 ? void 0 : n[this.$formName]) }, $formValue: function () { var t, n; return this.findNonEmpty((t = this.$pcFormField) === null || t === void 0 || (t = t.$field) === null || t === void 0 ? void 0 : t.value, (n = this.$pcForm) === null || n === void 0 || (n = n.getFieldState(this.$formName)) === null || n === void 0 ? void 0 : n.value) }, controlled: function () { return this.$inProps.hasOwnProperty("modelValue") || !this.$inProps.hasOwnProperty("modelValue") && !this.$inProps.hasOwnProperty("defaultValue") }, filled: function () { return this.$filled } } }, Ro = `
    .p-slider {
        display: block;
        position: relative;
        background: dt('slider.track.background');
        border-radius: dt('slider.track.border.radius');
    }

    .p-slider-handle {
        cursor: grab;
        touch-action: none;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: dt('slider.handle.height');
        width: dt('slider.handle.width');
        background: dt('slider.handle.background');
        border-radius: dt('slider.handle.border.radius');
        transition:
            background dt('slider.transition.duration'),
            color dt('slider.transition.duration'),
            border-color dt('slider.transition.duration'),
            box-shadow dt('slider.transition.duration'),
            outline-color dt('slider.transition.duration');
        outline-color: transparent;
    }

    .p-slider-handle::before {
        content: '';
        width: dt('slider.handle.content.width');
        height: dt('slider.handle.content.height');
        display: block;
        background: dt('slider.handle.content.background');
        border-radius: dt('slider.handle.content.border.radius');
        box-shadow: dt('slider.handle.content.shadow');
        transition: background dt('slider.transition.duration');
    }

    .p-slider:not(.p-disabled) .p-slider-handle:hover {
        background: dt('slider.handle.hover.background');
    }

    .p-slider:not(.p-disabled) .p-slider-handle:hover::before {
        background: dt('slider.handle.content.hover.background');
    }

    .p-slider-handle:focus-visible {
        box-shadow: dt('slider.handle.focus.ring.shadow');
        outline: dt('slider.handle.focus.ring.width') dt('slider.handle.focus.ring.style') dt('slider.handle.focus.ring.color');
        outline-offset: dt('slider.handle.focus.ring.offset');
    }

    .p-slider-range {
        display: block;
        background: dt('slider.range.background');
        border-radius: dt('slider.track.border.radius');
    }

    .p-slider.p-slider-horizontal {
        height: dt('slider.track.size');
    }

    .p-slider-horizontal .p-slider-range {
        inset-block-start: 0;
        inset-inline-start: 0;
        height: 100%;
    }

    .p-slider-horizontal .p-slider-handle {
        inset-block-start: 50%;
        margin-block-start: calc(-1 * calc(dt('slider.handle.height') / 2));
        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));
    }

    .p-slider-vertical {
        min-height: 100px;
        width: dt('slider.track.size');
    }

    .p-slider-vertical .p-slider-handle {
        inset-inline-start: 50%;
        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));
        margin-block-end: calc(-1 * calc(dt('slider.handle.height') / 2));
    }

    .p-slider-vertical .p-slider-range {
        inset-block-end: 0;
        inset-inline-start: 0;
        width: 100%;
    }
`, $o = { handle: { position: "absolute" }, range: { position: "absolute" } }, Ho = { root: function (t) { var n = t.instance, i = t.props; return ["p-slider p-component", { "p-disabled": i.disabled, "p-invalid": n.$invalid, "p-slider-horizontal": i.orientation === "horizontal", "p-slider-vertical": i.orientation === "vertical" }] }, range: "p-slider-range", handle: "p-slider-handle" }, Vo = ci.extend({ name: "slider", style: Ro, classes: Ho, inlineStyles: $o }), No = { name: "BaseSlider", extends: Oo, props: { min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, orientation: { type: String, default: "horizontal" }, step: { type: Number, default: null }, range: { type: Boolean, default: !1 }, tabindex: { type: Number, default: 0 }, ariaLabelledby: { type: String, default: null }, ariaLabel: { type: String, default: null } }, style: Vo, provide: function () { return { $pcSlider: this, $parentInstance: this } } }; function rt(e) { "@babel/helpers - typeof"; return rt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, rt(e) } function jo(e, t, n) { return (t = Ko(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function Ko(e) { var t = Wo(e, "string"); return rt(t) == "symbol" ? t : t + "" } function Wo(e, t) { if (rt(e) != "object" || !e) return e; var n = e[Symbol.toPrimitive]; if (n !== void 0) { var i = n.call(e, t); if (rt(i) != "object") return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } function qo(e) { return Go(e) || Qo(e) || Uo(e) || Yo() } function Yo() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function Uo(e, t) { if (e) { if (typeof e == "string") return Gt(e, t); var n = {}.toString.call(e).slice(8, -1); return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Gt(e, t) : void 0 } } function Qo(e) { if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e) } function Go(e) { if (Array.isArray(e)) return Gt(e) } function Gt(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, i = Array(t); n < t; n++)i[n] = e[n]; return i } var ki = { name: "Slider", extends: No, inheritAttrs: !1, emits: ["change", "slideend"], dragging: !1, handleIndex: null, initX: null, initY: null, barWidth: null, barHeight: null, dragListener: null, dragEndListener: null, beforeUnmount: function () { this.unbindDragListeners() }, methods: { updateDomData: function () { var t = this.$el.getBoundingClientRect(); this.initX = t.left + Gr(), this.initY = t.top + Xr(), this.barWidth = this.$el.offsetWidth, this.barHeight = this.$el.offsetHeight }, setValue: function (t) { var n, i = t.touches ? t.touches[0].pageX : t.pageX, o = t.touches ? t.touches[0].pageY : t.pageY; this.orientation === "horizontal" ? Qr(this.$el) ? n = (this.initX + this.barWidth - i) * 100 / this.barWidth : n = (i - this.initX) * 100 / this.barWidth : n = (this.initY + this.barHeight - o) * 100 / this.barHeight; var r = (this.max - this.min) * (n / 100) + this.min; if (this.step) { var a = this.range ? this.value[this.handleIndex] : this.value, l = r - a; l < 0 ? r = a + Math.ceil(r / this.step - a / this.step) * this.step : l > 0 && (r = a + Math.floor(r / this.step - a / this.step) * this.step) } else r = Math.floor(r); this.updateModel(t, r) }, updateModel: function (t, n) { var i = Math.round(n * 100) / 100, o; this.range ? (o = this.value ? qo(this.value) : [], this.handleIndex == 0 ? (i < this.min ? i = this.min : i >= this.max && (i = this.max), o[0] = i) : (i > this.max ? i = this.max : i <= this.min && (i = this.min), o[1] = i)) : (i < this.min ? i = this.min : i > this.max && (i = this.max), o = i), this.writeValue(o, t), this.$emit("change", o) }, onDragStart: function (t, n) { this.disabled || (this.$el.setAttribute("data-p-sliding", !0), this.dragging = !0, this.updateDomData(), this.range && this.value[0] === this.max ? this.handleIndex = 0 : this.handleIndex = n, t.currentTarget.focus()) }, onDrag: function (t) { this.dragging && this.setValue(t) }, onDragEnd: function (t) { this.dragging && (this.dragging = !1, this.$el.setAttribute("data-p-sliding", !1), this.$emit("slideend", { originalEvent: t, value: this.value })) }, onBarClick: function (t) { this.disabled || Ur(t.target, "data-pc-section") !== "handle" && (this.updateDomData(), this.setValue(t)) }, onMouseDown: function (t, n) { this.bindDragListeners(), this.onDragStart(t, n) }, onKeyDown: function (t, n) { switch (this.handleIndex = n, t.code) { case "ArrowDown": case "ArrowLeft": this.decrementValue(t, n), t.preventDefault(); break; case "ArrowUp": case "ArrowRight": this.incrementValue(t, n), t.preventDefault(); break; case "PageDown": this.decrementValue(t, n, !0), t.preventDefault(); break; case "PageUp": this.incrementValue(t, n, !0), t.preventDefault(); break; case "Home": this.updateModel(t, this.min), t.preventDefault(); break; case "End": this.updateModel(t, this.max), t.preventDefault(); break } }, onBlur: function (t, n) { var i, o; (i = (o = this.formField).onBlur) === null || i === void 0 || i.call(o, t) }, decrementValue: function (t, n) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, o; this.range ? this.step ? o = this.value[n] - this.step : o = this.value[n] - 1 : this.step ? o = this.value - this.step : !this.step && i ? o = this.value - 10 : o = this.value - 1, this.updateModel(t, o), t.preventDefault() }, incrementValue: function (t, n) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, o; this.range ? this.step ? o = this.value[n] + this.step : o = this.value[n] + 1 : this.step ? o = this.value + this.step : !this.step && i ? o = this.value + 10 : o = this.value + 1, this.updateModel(t, o), t.preventDefault() }, bindDragListeners: function () { this.dragListener || (this.dragListener = this.onDrag.bind(this), document.addEventListener("mousemove", this.dragListener)), this.dragEndListener || (this.dragEndListener = this.onDragEnd.bind(this), document.addEventListener("mouseup", this.dragEndListener)) }, unbindDragListeners: function () { this.dragListener && (document.removeEventListener("mousemove", this.dragListener), this.dragListener = null), this.dragEndListener && (document.removeEventListener("mouseup", this.dragEndListener), this.dragEndListener = null) }, rangeStyle: function () { if (this.range) { var t = this.rangeEndPosition > this.rangeStartPosition ? this.rangeEndPosition - this.rangeStartPosition : this.rangeStartPosition - this.rangeEndPosition, n = this.rangeEndPosition > this.rangeStartPosition ? this.rangeStartPosition : this.rangeEndPosition; return this.horizontal ? { "inset-inline-start": n + "%", width: t + "%" } : { bottom: n + "%", height: t + "%" } } else return this.horizontal ? { width: this.handlePosition + "%" } : { height: this.handlePosition + "%" } }, handleStyle: function () { return this.horizontal ? { "inset-inline-start": this.handlePosition + "%" } : { bottom: this.handlePosition + "%" } }, rangeStartHandleStyle: function () { return this.horizontal ? { "inset-inline-start": this.rangeStartPosition + "%" } : { bottom: this.rangeStartPosition + "%" } }, rangeEndHandleStyle: function () { return this.horizontal ? { "inset-inline-start": this.rangeEndPosition + "%" } : { bottom: this.rangeEndPosition + "%" } } }, computed: { value: function () { var t; if (this.range) { var n, i, o, r; return [(n = (i = this.d_value) === null || i === void 0 ? void 0 : i[0]) !== null && n !== void 0 ? n : this.min, (o = (r = this.d_value) === null || r === void 0 ? void 0 : r[1]) !== null && o !== void 0 ? o : this.max] } return (t = this.d_value) !== null && t !== void 0 ? t : this.min }, horizontal: function () { return this.orientation === "horizontal" }, vertical: function () { return this.orientation === "vertical" }, handlePosition: function () { return this.value < this.min ? 0 : this.value > this.max ? 100 : (this.value - this.min) * 100 / (this.max - this.min) }, rangeStartPosition: function () { return this.value && this.value[0] !== void 0 ? this.value[0] < this.min ? 0 : (this.value[0] - this.min) * 100 / (this.max - this.min) : 0 }, rangeEndPosition: function () { return this.value && this.value.length === 2 && this.value[1] !== void 0 ? this.value[1] > this.max ? 100 : (this.value[1] - this.min) * 100 / (this.max - this.min) : 100 }, dataP: function () { return Yr(jo({}, this.orientation, this.orientation)) } } }, Xo = ["data-p"], Jo = ["data-p"], Zo = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"], ea = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"], ta = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"]; function na(e, t, n, i, o, r) { return H(), Y("div", G({ class: e.cx("root"), onClick: t[18] || (t[18] = function () { return r.onBarClick && r.onBarClick.apply(r, arguments) }) }, e.ptmi("root"), { "data-p-sliding": !1, "data-p": r.dataP }), [J("span", G({ class: e.cx("range"), style: [e.sx("range"), r.rangeStyle()] }, e.ptm("range"), { "data-p": r.dataP }), null, 16, Jo), e.range ? ee("", !0) : (H(), Y("span", G({ key: 0, class: e.cx("handle"), style: [e.sx("handle"), r.handleStyle()], onTouchstartPassive: t[0] || (t[0] = function (a) { return r.onDragStart(a) }), onTouchmovePassive: t[1] || (t[1] = function (a) { return r.onDrag(a) }), onTouchend: t[2] || (t[2] = function (a) { return r.onDragEnd(a) }), onMousedown: t[3] || (t[3] = function (a) { return r.onMouseDown(a) }), onKeydown: t[4] || (t[4] = function (a) { return r.onKeyDown(a) }), onBlur: t[5] || (t[5] = function (a) { return r.onBlur(a) }), tabindex: e.tabindex, role: "slider", "aria-valuemin": e.min, "aria-valuenow": e.d_value, "aria-valuemax": e.max, "aria-labelledby": e.ariaLabelledby, "aria-label": e.ariaLabel, "aria-orientation": e.orientation }, e.ptm("handle"), { "data-p": r.dataP }), null, 16, Zo)), e.range ? (H(), Y("span", G({ key: 1, class: e.cx("handle"), style: [e.sx("handle"), r.rangeStartHandleStyle()], onTouchstartPassive: t[6] || (t[6] = function (a) { return r.onDragStart(a, 0) }), onTouchmovePassive: t[7] || (t[7] = function (a) { return r.onDrag(a) }), onTouchend: t[8] || (t[8] = function (a) { return r.onDragEnd(a) }), onMousedown: t[9] || (t[9] = function (a) { return r.onMouseDown(a, 0) }), onKeydown: t[10] || (t[10] = function (a) { return r.onKeyDown(a, 0) }), onBlur: t[11] || (t[11] = function (a) { return r.onBlur(a, 0) }), tabindex: e.tabindex, role: "slider", "aria-valuemin": e.min, "aria-valuenow": e.d_value ? e.d_value[0] : null, "aria-valuemax": e.max, "aria-labelledby": e.ariaLabelledby, "aria-label": e.ariaLabel, "aria-orientation": e.orientation }, e.ptm("startHandler"), { "data-p": r.dataP }), null, 16, ea)) : ee("", !0), e.range ? (H(), Y("span", G({ key: 2, class: e.cx("handle"), style: [e.sx("handle"), r.rangeEndHandleStyle()], onTouchstartPassive: t[12] || (t[12] = function (a) { return r.onDragStart(a, 1) }), onTouchmovePassive: t[13] || (t[13] = function (a) { return r.onDrag(a) }), onTouchend: t[14] || (t[14] = function (a) { return r.onDragEnd(a) }), onMousedown: t[15] || (t[15] = function (a) { return r.onMouseDown(a, 1) }), onKeydown: t[16] || (t[16] = function (a) { return r.onKeyDown(a, 1) }), onBlur: t[17] || (t[17] = function (a) { return r.onBlur(a, 1) }), tabindex: e.tabindex, role: "slider", "aria-valuemin": e.min, "aria-valuenow": e.d_value ? e.d_value[1] : null, "aria-valuemax": e.max, "aria-labelledby": e.ariaLabelledby, "aria-label": e.ariaLabel, "aria-orientation": e.orientation }, e.ptm("endHandler"), { "data-p": r.dataP }), null, 16, ta)) : ee("", !0)], 16, Xo) } ki.render = na; const ia = { class: "dialog-content" }, ra = { class: "form-row" }, oa = { class: "row-value" }, aa = { class: "dialog-footer" }, la = at({ __name: "opacity-setting-dialog", props: { visible: { type: Boolean }, opacity: {} }, emits: ["update:visible", "update:opacity", "confirm"], setup(e, { emit: t }) { const n = e, i = t, o = ae(n.visible), r = ae(n.opacity); zt(() => n.visible, u => { o.value = u, u && (r.value = n.opacity) }), zt(o, u => { i("update:visible", u) }), zt(() => r.value, u => { i("update:opacity", u) }); function a() { o.value = !1 } function l() { i("confirm", r.value), o.value = !1 } return (u, s) => (H(), Se(je(Jr), { visible: o.value, "onUpdate:visible": s[1] || (s[1] = c => o.value = c), position: "center", draggable: !1, style: { "max-width": "250px", width: "70vw" } }, { container: tt(() => [s[2] || (s[2] = J("div", { class: "dialog-header" }, "背景透明度", -1)), J("div", ia, [J("div", ra, [ke(je(ki), { modelValue: r.value, "onUpdate:modelValue": s[0] || (s[0] = c => r.value = c), min: 0, max: 1, step: .01 }, null, 8, ["modelValue"]), J("label", oa, Be(r.value), 1)])]), J("div", aa, [ke(je(En), { size: "small", type: "button", label: "取消", severity: "secondary", onClick: a }), ke(je(En), { size: "small", type: "button", label: "确定", onClick: l })])]), _: 1 }, 8, ["visible"])) } }), wi = It(la, [["__scopeId", "data-v-e085d9ac"]]), sa = {}; function cn(e, t) { const n = sa, i = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0; return xi(e, i, o) } function xi(e, t, n) { if (ua(e)) { if ("value" in e) return e.type === "html" && !n ? "" : e.value; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return Ln(e.children, t, n) } return Array.isArray(e) ? Ln(e, t, n) : "" } function Ln(e, t, n) { const i = []; let o = -1; for (; ++o < e.length;)i[o] = xi(e[o], t, n); return i.join("") } function ua(e) { return !!(e && typeof e == "object") } const Pn = document.createElement("i"); function dn(e) { const t = "&" + e + ";"; Pn.innerHTML = t; const n = Pn.textContent; return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n } function ce(e, t, n, i) { const o = e.length; let r = 0, a; if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, i.length < 1e4) a = Array.from(i), a.unshift(t, n), e.splice(...a); else for (n && e.splice(t, n); r < i.length;)a = i.slice(r, r + 1e4), a.unshift(t, 0), e.splice(...a), r += 1e4, t += 1e4 } function fe(e, t) { return e.length > 0 ? (ce(e, e.length, 0, t), e) : t } const Fn = {}.hasOwnProperty; function Ii(e) { const t = {}; let n = -1; for (; ++n < e.length;)ca(t, e[n]); return t } function ca(e, t) { let n; for (n in t) { const o = (Fn.call(e, n) ? e[n] : void 0) || (e[n] = {}), r = t[n]; let a; if (r) for (a in r) { Fn.call(o, a) || (o[a] = []); const l = r[a]; da(o[a], Array.isArray(l) ? l : l ? [l] : []) } } } function da(e, t) { let n = -1; const i = []; for (; ++n < t.length;)(t[n].add === "after" ? e : i).push(t[n]); ce(e, 0, 0, i) } function Si(e, t) { const n = Number.parseInt(e, t); return n < 9 || n === 11 || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || n > 1114111 ? "�" : String.fromCodePoint(n) } function ye(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const ie = Pe(/[A-Za-z]/), le = Pe(/[\dA-Za-z]/), ha = Pe(/[#-'*+\--9=?A-Z^-~]/); function yt(e) { return e !== null && (e < 32 || e === 127) } const Xt = Pe(/\d/), fa = Pe(/[\dA-Fa-f]/), pa = Pe(/[!-/:-@[-`{-~]/); function B(e) { return e !== null && e < -2 } function Q(e) { return e !== null && (e < 0 || e === 32) } function j(e) { return e === -2 || e === -1 || e === 32 } const St = Pe(new RegExp("\\p{P}|\\p{S}", "u")), Re = Pe(/\s/); function Pe(e) { return t; function t(n) { return n !== null && n > -1 && e.test(String.fromCharCode(n)) } } function q(e, t, n, i) { const o = i ? i - 1 : Number.POSITIVE_INFINITY; let r = 0; return a; function a(u) { return j(u) ? (e.enter(n), l(u)) : t(u) } function l(u) { return j(u) && r++ < o ? (e.consume(u), l) : (e.exit(n), t(u)) } } const ma = { tokenize: ga }; function ga(e) { const t = e.attempt(this.parser.constructs.contentInitial, i, o); let n; return t; function i(l) { if (l === null) { e.consume(l); return } return e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), q(e, t, "linePrefix") } function o(l) { return e.enter("paragraph"), r(l) } function r(l) { const u = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = u), n = u, a(l) } function a(l) { if (l === null) { e.exit("chunkText"), e.exit("paragraph"), e.consume(l); return } return B(l) ? (e.consume(l), e.exit("chunkText"), r) : (e.consume(l), a) } } const ba = { tokenize: ya }, Dn = { tokenize: va }; function ya(e) { const t = this, n = []; let i = 0, o, r, a; return l; function l(I) { if (i < n.length) { const M = n[i]; return t.containerState = M[1], e.attempt(M[0].continuation, u, s)(I) } return s(I) } function u(I) { if (i++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, o && S(); const M = t.events.length; let F = M, v; for (; F--;)if (t.events[F][0] === "exit" && t.events[F][1].type === "chunkFlow") { v = t.events[F][1].end; break } y(i); let O = M; for (; O < t.events.length;)t.events[O][1].end = { ...v }, O++; return ce(t.events, F + 1, 0, t.events.slice(M)), t.events.length = O, s(I) } return l(I) } function s(I) { if (i === n.length) { if (!o) return f(I); if (o.currentConstruct && o.currentConstruct.concrete) return g(I); t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(Dn, c, d)(I) } function c(I) { return o && S(), y(i), f(I) } function d(I) { return t.parser.lazy[t.now().line] = i !== n.length, a = t.now().offset, g(I) } function f(I) { return t.containerState = {}, e.attempt(Dn, h, g)(I) } function h(I) { return i++, n.push([t.currentConstruct, t.containerState]), f(I) } function g(I) { if (I === null) { o && S(), y(0), e.consume(I); return } return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: o, contentType: "flow", previous: r }), k(I) } function k(I) { if (I === null) { w(e.exit("chunkFlow"), !0), y(0), e.consume(I); return } return B(I) ? (e.consume(I), w(e.exit("chunkFlow")), i = 0, t.interrupt = void 0, l) : (e.consume(I), k) } function w(I, M) { const F = t.sliceStream(I); if (M && F.push(null), I.previous = r, r && (r.next = I), r = I, o.defineSkip(I.start), o.write(F), t.parser.lazy[I.start.line]) { let v = o.events.length; for (; v--;)if (o.events[v][1].start.offset < a && (!o.events[v][1].end || o.events[v][1].end.offset > a)) return; const O = t.events.length; let K = O, E, b; for (; K--;)if (t.events[K][0] === "exit" && t.events[K][1].type === "chunkFlow") { if (E) { b = t.events[K][1].end; break } E = !0 } for (y(i), v = O; v < t.events.length;)t.events[v][1].end = { ...b }, v++; ce(t.events, K + 1, 0, t.events.slice(O)), t.events.length = v } } function y(I) { let M = n.length; for (; M-- > I;) { const F = n[M]; t.containerState = F[1], F[0].exit.call(t, e) } n.length = I } function S() { o.write([null]), r = void 0, o = void 0, t.containerState._closeFlow = void 0 } } function va(e, t, n) { return q(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } function We(e) { if (e === null || Q(e) || Re(e)) return 1; if (St(e)) return 2 } function Ct(e, t, n) { const i = []; let o = -1; for (; ++o < e.length;) { const r = e[o].resolveAll; r && !i.includes(r) && (t = r(t, n), i.push(r)) } return t } const Jt = { name: "attention", resolveAll: ka, tokenize: wa }; function ka(e, t) { let n = -1, i, o, r, a, l, u, s, c; for (; ++n < e.length;)if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) { for (i = n; i--;)if (e[i][0] === "exit" && e[i][1].type === "attentionSequence" && e[i][1]._open && t.sliceSerialize(e[i][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) { if ((e[i][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[i][1].end.offset - e[i][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3)) continue; u = e[i][1].end.offset - e[i][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1; const d = { ...e[i][1].end }, f = { ...e[n][1].start }; zn(d, -u), zn(f, u), a = { type: u > 1 ? "strongSequence" : "emphasisSequence", start: d, end: { ...e[i][1].end } }, l = { type: u > 1 ? "strongSequence" : "emphasisSequence", start: { ...e[n][1].start }, end: f }, r = { type: u > 1 ? "strongText" : "emphasisText", start: { ...e[i][1].end }, end: { ...e[n][1].start } }, o = { type: u > 1 ? "strong" : "emphasis", start: { ...a.start }, end: { ...l.end } }, e[i][1].end = { ...a.start }, e[n][1].start = { ...l.end }, s = [], e[i][1].end.offset - e[i][1].start.offset && (s = fe(s, [["enter", e[i][1], t], ["exit", e[i][1], t]])), s = fe(s, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["enter", r, t]]), s = fe(s, Ct(t.parser.constructs.insideSpan.null, e.slice(i + 1, n), t)), s = fe(s, [["exit", r, t], ["enter", l, t], ["exit", l, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (c = 2, s = fe(s, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : c = 0, ce(e, i - 1, n - i + 3, s), n = i + s.length - c - 2; break } } for (n = -1; ++n < e.length;)e[n][1].type === "attentionSequence" && (e[n][1].type = "data"); return e } function wa(e, t) { const n = this.parser.constructs.attentionMarkers.null, i = this.previous, o = We(i); let r; return a; function a(u) { return r = u, e.enter("attentionSequence"), l(u) } function l(u) { if (u === r) return e.consume(u), l; const s = e.exit("attentionSequence"), c = We(u), d = !c || c === 2 && o || n.includes(u), f = !o || o === 2 && c || n.includes(i); return s._open = !!(r === 42 ? d : d && (o || !f)), s._close = !!(r === 42 ? f : f && (c || !d)), t(u) } } function zn(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const xa = { name: "autolink", tokenize: Ia }; function Ia(e, t, n) { let i = 0; return o; function o(h) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), r } function r(h) { return ie(h) ? (e.consume(h), a) : h === 64 ? n(h) : s(h) } function a(h) { return h === 43 || h === 45 || h === 46 || le(h) ? (i = 1, l(h)) : s(h) } function l(h) { return h === 58 ? (e.consume(h), i = 0, u) : (h === 43 || h === 45 || h === 46 || le(h)) && i++ < 32 ? (e.consume(h), l) : (i = 0, s(h)) } function u(h) { return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || yt(h) ? n(h) : (e.consume(h), u) } function s(h) { return h === 64 ? (e.consume(h), c) : ha(h) ? (e.consume(h), s) : n(h) } function c(h) { return le(h) ? d(h) : n(h) } function d(h) { return h === 46 ? (e.consume(h), i = 0, c) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : f(h) } function f(h) { if ((h === 45 || le(h)) && i++ < 63) { const g = h === 45 ? f : d; return e.consume(h), g } return n(h) } } const lt = { partial: !0, tokenize: Sa }; function Sa(e, t, n) { return i; function i(r) { return j(r) ? q(e, o, "linePrefix")(r) : o(r) } function o(r) { return r === null || B(r) ? t(r) : n(r) } } const Ci = { continuation: { tokenize: Ea }, exit: Aa, name: "blockQuote", tokenize: Ca }; function Ca(e, t, n) { const i = this; return o; function o(a) { if (a === 62) { const l = i.containerState; return l.open || (e.enter("blockQuote", { _container: !0 }), l.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), r } return n(a) } function r(a) { return j(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a)) } } function Ea(e, t, n) { const i = this; return o; function o(a) { return j(a) ? q(e, r, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : r(a) } function r(a) { return e.attempt(Ci, t, n)(a) } } function Aa(e) { e.exit("blockQuote") } const Ei = { name: "characterEscape", tokenize: Ta }; function Ta(e, t, n) { return i; function i(r) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(r), e.exit("escapeMarker"), o } function o(r) { return pa(r) ? (e.enter("characterEscapeValue"), e.consume(r), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(r) } } const Ai = { name: "characterReference", tokenize: La }; function La(e, t, n) { const i = this; let o = 0, r, a; return l; function l(d) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), u } function u(d) { return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), s) : (e.enter("characterReferenceValue"), r = 31, a = le, c(d)) } function s(d) { return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), r = 6, a = fa, c) : (e.enter("characterReferenceValue"), r = 7, a = Xt, c(d)) } function c(d) { if (d === 59 && o) { const f = e.exit("characterReferenceValue"); return a === le && !dn(i.sliceSerialize(f)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) } return a(d) && o++ < r ? (e.consume(d), c) : n(d) } } const Mn = { partial: !0, tokenize: Fa }, _n = { concrete: !0, name: "codeFenced", tokenize: Pa }; function Pa(e, t, n) { const i = this, o = { partial: !0, tokenize: F }; let r = 0, a = 0, l; return u; function u(v) { return s(v) } function s(v) { const O = i.events[i.events.length - 1]; return r = O && O[1].type === "linePrefix" ? O[2].sliceSerialize(O[1], !0).length : 0, l = v, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(v) } function c(v) { return v === l ? (a++, e.consume(v), c) : a < 3 ? n(v) : (e.exit("codeFencedFenceSequence"), j(v) ? q(e, d, "whitespace")(v) : d(v)) } function d(v) { return v === null || B(v) ? (e.exit("codeFencedFence"), i.interrupt ? t(v) : e.check(Mn, k, M)(v)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), f(v)) } function f(v) { return v === null || B(v) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(v)) : j(v) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), q(e, h, "whitespace")(v)) : v === 96 && v === l ? n(v) : (e.consume(v), f) } function h(v) { return v === null || B(v) ? d(v) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), g(v)) } function g(v) { return v === null || B(v) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(v)) : v === 96 && v === l ? n(v) : (e.consume(v), g) } function k(v) { return e.attempt(o, M, w)(v) } function w(v) { return e.enter("lineEnding"), e.consume(v), e.exit("lineEnding"), y } function y(v) { return r > 0 && j(v) ? q(e, S, "linePrefix", r + 1)(v) : S(v) } function S(v) { return v === null || B(v) ? e.check(Mn, k, M)(v) : (e.enter("codeFlowValue"), I(v)) } function I(v) { return v === null || B(v) ? (e.exit("codeFlowValue"), S(v)) : (e.consume(v), I) } function M(v) { return e.exit("codeFenced"), t(v) } function F(v, O, K) { let E = 0; return b; function b(V) { return v.enter("lineEnding"), v.consume(V), v.exit("lineEnding"), T } function T(V) { return v.enter("codeFencedFence"), j(V) ? q(v, L, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : L(V) } function L(V) { return V === l ? (v.enter("codeFencedFenceSequence"), R(V)) : K(V) } function R(V) { return V === l ? (E++, v.consume(V), R) : E >= a ? (v.exit("codeFencedFenceSequence"), j(V) ? q(v, N, "whitespace")(V) : N(V)) : K(V) } function N(V) { return V === null || B(V) ? (v.exit("codeFencedFence"), O(V)) : K(V) } } } function Fa(e, t, n) { const i = this; return o; function o(a) { return a === null ? n(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), r) } function r(a) { return i.parser.lazy[i.now().line] ? n(a) : t(a) } } const Mt = { name: "codeIndented", tokenize: za }, Da = { partial: !0, tokenize: Ma }; function za(e, t, n) { const i = this; return o; function o(s) { return e.enter("codeIndented"), q(e, r, "linePrefix", 5)(s) } function r(s) { const c = i.events[i.events.length - 1]; return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(s) : n(s) } function a(s) { return s === null ? u(s) : B(s) ? e.attempt(Da, a, u)(s) : (e.enter("codeFlowValue"), l(s)) } function l(s) { return s === null || B(s) ? (e.exit("codeFlowValue"), a(s)) : (e.consume(s), l) } function u(s) { return e.exit("codeIndented"), t(s) } } function Ma(e, t, n) { const i = this; return o; function o(a) { return i.parser.lazy[i.now().line] ? n(a) : B(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : q(e, r, "linePrefix", 5)(a) } function r(a) { const l = i.events[i.events.length - 1]; return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? t(a) : B(a) ? o(a) : n(a) } } const _a = { name: "codeText", previous: Oa, resolve: Ba, tokenize: Ra }; function Ba(e) { let t = e.length - 4, n = 3, i, o; if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) { for (i = n; ++i < t;)if (e[i][1].type === "codeTextData") { e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2; break } } for (i = n - 1, t++; ++i <= t;)o === void 0 ? i !== t && e[i][1].type !== "lineEnding" && (o = i) : (i === t || e[i][1].type === "lineEnding") && (e[o][1].type = "codeTextData", i !== o + 2 && (e[o][1].end = e[i - 1][1].end, e.splice(o + 2, i - o - 2), t -= i - o - 2, i = o + 2), o = void 0); return e } function Oa(e) { return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape" } function Ra(e, t, n) { let i = 0, o, r; return a; function a(d) { return e.enter("codeText"), e.enter("codeTextSequence"), l(d) } function l(d) { return d === 96 ? (e.consume(d), i++, l) : (e.exit("codeTextSequence"), u(d)) } function u(d) { return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), u) : d === 96 ? (r = e.enter("codeTextSequence"), o = 0, c(d)) : B(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), u) : (e.enter("codeTextData"), s(d)) } function s(d) { return d === null || d === 32 || d === 96 || B(d) ? (e.exit("codeTextData"), u(d)) : (e.consume(d), s) } function c(d) { return d === 96 ? (e.consume(d), o++, c) : o === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (r.type = "codeTextData", s(d)) } } class $a { constructor(t) { this.left = t ? [...t] : [], this.right = [] } get(t) { if (t < 0 || t >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(t, n) { const i = n ?? Number.POSITIVE_INFINITY; return i < this.left.length ? this.left.slice(t, i) : t > this.left.length ? this.right.slice(this.right.length - i + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - i + this.left.length).reverse()) } splice(t, n, i) { const o = n || 0; this.setCursor(Math.trunc(t)); const r = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY); return i && Qe(this.left, i), r.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(t) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t) } pushMany(t) { this.setCursor(Number.POSITIVE_INFINITY), Qe(this.left, t) } unshift(t) { this.setCursor(0), this.right.push(t) } unshiftMany(t) { this.setCursor(0), Qe(this.right, t.reverse()) } setCursor(t) { if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0)) if (t < this.left.length) { const n = this.left.splice(t, Number.POSITIVE_INFINITY); Qe(this.right, n.reverse()) } else { const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY); Qe(this.left, n.reverse()) } } } function Qe(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function Ti(e) { const t = {}; let n = -1, i, o, r, a, l, u, s; const c = new $a(e); for (; ++n < c.length;) { for (; n in t;)n = t[n]; if (i = c.get(n), n && i[1].type === "chunkFlow" && c.get(n - 1)[1].type === "listItemPrefix" && (u = i[1]._tokenizer.events, r = 0, r < u.length && u[r][1].type === "lineEndingBlank" && (r += 2), r < u.length && u[r][1].type === "content")) for (; ++r < u.length && u[r][1].type !== "content";)u[r][1].type === "chunkText" && (u[r][1]._isInFirstContentOfListItem = !0, r++); if (i[0] === "enter") i[1].contentType && (Object.assign(t, Ha(c, n)), n = t[n], s = !0); else if (i[1]._container) { for (r = n, o = void 0; r--;)if (a = c.get(r), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank") a[0] === "enter" && (o && (c.get(o)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", o = r); else if (!(a[1].type === "linePrefix" || a[1].type === "listItemIndent")) break; o && (i[1].end = { ...c.get(o)[1].start }, l = c.slice(o, n), l.unshift(i), c.splice(o, n - o + 1, l)) } } return ce(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !s } function Ha(e, t) { const n = e.get(t)[1], i = e.get(t)[2]; let o = t - 1; const r = []; let a = n._tokenizer; a || (a = i.parser[n.contentType](n.start), n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0)); const l = a.events, u = [], s = {}; let c, d, f = -1, h = n, g = 0, k = 0; const w = [k]; for (; h;) { for (; e.get(++o)[1] !== h;); r.push(o), h._tokenizer || (c = i.sliceStream(h), h.next || c.push(null), d && a.defineSkip(h.start), h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = h, h = h.next } for (h = n; ++f < l.length;)l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (k = f + 1, w.push(k), h._tokenizer = void 0, h.previous = void 0, h = h.next); for (a.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : w.pop(), f = w.length; f--;) { const y = l.slice(w[f], w[f + 1]), S = r.pop(); u.push([S, S + y.length - 1]), e.splice(S, 2, y) } for (u.reverse(), f = -1; ++f < u.length;)s[g + u[f][0]] = g + u[f][1], g += u[f][1] - u[f][0] - 1; return s } const Va = { resolve: ja, tokenize: Ka }, Na = { partial: !0, tokenize: Wa }; function ja(e) { return Ti(e), e } function Ka(e, t) { let n; return i; function i(l) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), o(l) } function o(l) { return l === null ? r(l) : B(l) ? e.check(Na, a, r)(l) : (e.consume(l), o) } function r(l) { return e.exit("chunkContent"), e.exit("content"), t(l) } function a(l) { return e.consume(l), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, o } } function Wa(e, t, n) { const i = this; return o; function o(a) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), q(e, r, "linePrefix") } function r(a) { if (a === null || B(a)) return n(a); const l = i.events[i.events.length - 1]; return !i.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? t(a) : e.interrupt(i.parser.constructs.flow, n, t)(a) } } function Li(e, t, n, i, o, r, a, l, u) { const s = u || Number.POSITIVE_INFINITY; let c = 0; return d; function d(y) { return y === 60 ? (e.enter(i), e.enter(o), e.enter(r), e.consume(y), e.exit(r), f) : y === null || y === 32 || y === 41 || yt(y) ? n(y) : (e.enter(i), e.enter(a), e.enter(l), e.enter("chunkString", { contentType: "string" }), k(y)) } function f(y) { return y === 62 ? (e.enter(r), e.consume(y), e.exit(r), e.exit(o), e.exit(i), t) : (e.enter(l), e.enter("chunkString", { contentType: "string" }), h(y)) } function h(y) { return y === 62 ? (e.exit("chunkString"), e.exit(l), f(y)) : y === null || y === 60 || B(y) ? n(y) : (e.consume(y), y === 92 ? g : h) } function g(y) { return y === 60 || y === 62 || y === 92 ? (e.consume(y), h) : h(y) } function k(y) { return !c && (y === null || y === 41 || Q(y)) ? (e.exit("chunkString"), e.exit(l), e.exit(a), e.exit(i), t(y)) : c < s && y === 40 ? (e.consume(y), c++, k) : y === 41 ? (e.consume(y), c--, k) : y === null || y === 32 || y === 40 || yt(y) ? n(y) : (e.consume(y), y === 92 ? w : k) } function w(y) { return y === 40 || y === 41 || y === 92 ? (e.consume(y), k) : k(y) } } function Pi(e, t, n, i, o, r) { const a = this; let l = 0, u; return s; function s(h) { return e.enter(i), e.enter(o), e.consume(h), e.exit(o), e.enter(r), c } function c(h) { return l > 999 || h === null || h === 91 || h === 93 && !u || h === 94 && !l && "_hiddenFootnoteSupport" in a.parser.constructs ? n(h) : h === 93 ? (e.exit(r), e.enter(o), e.consume(h), e.exit(o), e.exit(i), t) : B(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("chunkString", { contentType: "string" }), d(h)) } function d(h) { return h === null || h === 91 || h === 93 || B(h) || l++ > 999 ? (e.exit("chunkString"), c(h)) : (e.consume(h), u || (u = !j(h)), h === 92 ? f : d) } function f(h) { return h === 91 || h === 92 || h === 93 ? (e.consume(h), l++, d) : d(h) } } function Fi(e, t, n, i, o, r) { let a; return l; function l(f) { return f === 34 || f === 39 || f === 40 ? (e.enter(i), e.enter(o), e.consume(f), e.exit(o), a = f === 40 ? 41 : f, u) : n(f) } function u(f) { return f === a ? (e.enter(o), e.consume(f), e.exit(o), e.exit(i), t) : (e.enter(r), s(f)) } function s(f) { return f === a ? (e.exit(r), u(a)) : f === null ? n(f) : B(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), q(e, s, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), c(f)) } function c(f) { return f === a || f === null || B(f) ? (e.exit("chunkString"), s(f)) : (e.consume(f), f === 92 ? d : c) } function d(f) { return f === a || f === 92 ? (e.consume(f), c) : c(f) } } function Ze(e, t) { let n; return i; function i(o) { return B(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, i) : j(o) ? q(e, i, n ? "linePrefix" : "lineSuffix")(o) : t(o) } } const qa = { name: "definition", tokenize: Ua }, Ya = { partial: !0, tokenize: Qa }; function Ua(e, t, n) { const i = this; let o; return r; function r(h) { return e.enter("definition"), a(h) } function a(h) { return Pi.call(i, e, l, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(h) } function l(h) { return o = ye(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1)), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), u) : n(h) } function u(h) { return Q(h) ? Ze(e, s)(h) : s(h) } function s(h) { return Li(e, c, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(h) } function c(h) { return e.attempt(Ya, d, d)(h) } function d(h) { return j(h) ? q(e, f, "whitespace")(h) : f(h) } function f(h) { return h === null || B(h) ? (e.exit("definition"), i.parser.defined.push(o), t(h)) : n(h) } } function Qa(e, t, n) { return i; function i(l) { return Q(l) ? Ze(e, o)(l) : n(l) } function o(l) { return Fi(e, r, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l) } function r(l) { return j(l) ? q(e, a, "whitespace")(l) : a(l) } function a(l) { return l === null || B(l) ? t(l) : n(l) } } const Ga = { name: "hardBreakEscape", tokenize: Xa }; function Xa(e, t, n) { return i; function i(r) { return e.enter("hardBreakEscape"), e.consume(r), o } function o(r) { return B(r) ? (e.exit("hardBreakEscape"), t(r)) : n(r) } } const Ja = { name: "headingAtx", resolve: Za, tokenize: el }; function Za(e, t) { let n = e.length - 2, i = 3, o, r; return e[i][1].type === "whitespace" && (i += 2), n - 2 > i && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (i === n - 1 || n - 4 > i && e[n - 2][1].type === "whitespace") && (n -= i + 1 === n ? 2 : 4), n > i && (o = { type: "atxHeadingText", start: e[i][1].start, end: e[n][1].end }, r = { type: "chunkText", start: e[i][1].start, end: e[n][1].end, contentType: "text" }, ce(e, i, n - i + 1, [["enter", o, t], ["enter", r, t], ["exit", r, t], ["exit", o, t]])), e } function el(e, t, n) { let i = 0; return o; function o(c) { return e.enter("atxHeading"), r(c) } function r(c) { return e.enter("atxHeadingSequence"), a(c) } function a(c) { return c === 35 && i++ < 6 ? (e.consume(c), a) : c === null || Q(c) ? (e.exit("atxHeadingSequence"), l(c)) : n(c) } function l(c) { return c === 35 ? (e.enter("atxHeadingSequence"), u(c)) : c === null || B(c) ? (e.exit("atxHeading"), t(c)) : j(c) ? q(e, l, "whitespace")(c) : (e.enter("atxHeadingText"), s(c)) } function u(c) { return c === 35 ? (e.consume(c), u) : (e.exit("atxHeadingSequence"), l(c)) } function s(c) { return c === null || c === 35 || Q(c) ? (e.exit("atxHeadingText"), l(c)) : (e.consume(c), s) } } const tl = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Bn = ["pre", "script", "style", "textarea"], nl = { concrete: !0, name: "htmlFlow", resolveTo: ol, tokenize: al }, il = { partial: !0, tokenize: sl }, rl = { partial: !0, tokenize: ll }; function ol(e) { let t = e.length; for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow");); return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e } function al(e, t, n) { const i = this; let o, r, a, l, u; return s; function s(m) { return c(m) } function c(m) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(m), d } function d(m) { return m === 33 ? (e.consume(m), f) : m === 47 ? (e.consume(m), r = !0, k) : m === 63 ? (e.consume(m), o = 3, i.interrupt ? t : p) : ie(m) ? (e.consume(m), a = String.fromCharCode(m), w) : n(m) } function f(m) { return m === 45 ? (e.consume(m), o = 2, h) : m === 91 ? (e.consume(m), o = 5, l = 0, g) : ie(m) ? (e.consume(m), o = 4, i.interrupt ? t : p) : n(m) } function h(m) { return m === 45 ? (e.consume(m), i.interrupt ? t : p) : n(m) } function g(m) { const me = "CDATA["; return m === me.charCodeAt(l++) ? (e.consume(m), l === me.length ? i.interrupt ? t : L : g) : n(m) } function k(m) { return ie(m) ? (e.consume(m), a = String.fromCharCode(m), w) : n(m) } function w(m) { if (m === null || m === 47 || m === 62 || Q(m)) { const me = m === 47, Fe = a.toLowerCase(); return !me && !r && Bn.includes(Fe) ? (o = 1, i.interrupt ? t(m) : L(m)) : tl.includes(a.toLowerCase()) ? (o = 6, me ? (e.consume(m), y) : i.interrupt ? t(m) : L(m)) : (o = 7, i.interrupt && !i.parser.lazy[i.now().line] ? n(m) : r ? S(m) : I(m)) } return m === 45 || le(m) ? (e.consume(m), a += String.fromCharCode(m), w) : n(m) } function y(m) { return m === 62 ? (e.consume(m), i.interrupt ? t : L) : n(m) } function S(m) { return j(m) ? (e.consume(m), S) : b(m) } function I(m) { return m === 47 ? (e.consume(m), b) : m === 58 || m === 95 || ie(m) ? (e.consume(m), M) : j(m) ? (e.consume(m), I) : b(m) } function M(m) { return m === 45 || m === 46 || m === 58 || m === 95 || le(m) ? (e.consume(m), M) : F(m) } function F(m) { return m === 61 ? (e.consume(m), v) : j(m) ? (e.consume(m), F) : I(m) } function v(m) { return m === null || m === 60 || m === 61 || m === 62 || m === 96 ? n(m) : m === 34 || m === 39 ? (e.consume(m), u = m, O) : j(m) ? (e.consume(m), v) : K(m) } function O(m) { return m === u ? (e.consume(m), u = null, E) : m === null || B(m) ? n(m) : (e.consume(m), O) } function K(m) { return m === null || m === 34 || m === 39 || m === 47 || m === 60 || m === 61 || m === 62 || m === 96 || Q(m) ? F(m) : (e.consume(m), K) } function E(m) { return m === 47 || m === 62 || j(m) ? I(m) : n(m) } function b(m) { return m === 62 ? (e.consume(m), T) : n(m) } function T(m) { return m === null || B(m) ? L(m) : j(m) ? (e.consume(m), T) : n(m) } function L(m) { return m === 45 && o === 2 ? (e.consume(m), C) : m === 60 && o === 1 ? (e.consume(m), P) : m === 62 && o === 4 ? (e.consume(m), X) : m === 63 && o === 3 ? (e.consume(m), p) : m === 93 && o === 5 ? (e.consume(m), Z) : B(m) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(il, de, R)(m)) : m === null || B(m) ? (e.exit("htmlFlowData"), R(m)) : (e.consume(m), L) } function R(m) { return e.check(rl, N, de)(m) } function N(m) { return e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), V } function V(m) { return m === null || B(m) ? R(m) : (e.enter("htmlFlowData"), L(m)) } function C(m) { return m === 45 ? (e.consume(m), p) : L(m) } function P(m) { return m === 47 ? (e.consume(m), a = "", _) : L(m) } function _(m) { if (m === 62) { const me = a.toLowerCase(); return Bn.includes(me) ? (e.consume(m), X) : L(m) } return ie(m) && a.length < 8 ? (e.consume(m), a += String.fromCharCode(m), _) : L(m) } function Z(m) { return m === 93 ? (e.consume(m), p) : L(m) } function p(m) { return m === 62 ? (e.consume(m), X) : m === 45 && o === 2 ? (e.consume(m), p) : L(m) } function X(m) { return m === null || B(m) ? (e.exit("htmlFlowData"), de(m)) : (e.consume(m), X) } function de(m) { return e.exit("htmlFlow"), t(m) } } function ll(e, t, n) { const i = this; return o; function o(a) { return B(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), r) : n(a) } function r(a) { return i.parser.lazy[i.now().line] ? n(a) : t(a) } } function sl(e, t, n) { return i; function i(o) { return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(lt, t, n) } } const ul = { name: "htmlText", tokenize: cl }; function cl(e, t, n) { const i = this; let o, r, a; return l; function l(p) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(p), u } function u(p) { return p === 33 ? (e.consume(p), s) : p === 47 ? (e.consume(p), F) : p === 63 ? (e.consume(p), I) : ie(p) ? (e.consume(p), K) : n(p) } function s(p) { return p === 45 ? (e.consume(p), c) : p === 91 ? (e.consume(p), r = 0, g) : ie(p) ? (e.consume(p), S) : n(p) } function c(p) { return p === 45 ? (e.consume(p), h) : n(p) } function d(p) { return p === null ? n(p) : p === 45 ? (e.consume(p), f) : B(p) ? (a = d, P(p)) : (e.consume(p), d) } function f(p) { return p === 45 ? (e.consume(p), h) : d(p) } function h(p) { return p === 62 ? C(p) : p === 45 ? f(p) : d(p) } function g(p) { const X = "CDATA["; return p === X.charCodeAt(r++) ? (e.consume(p), r === X.length ? k : g) : n(p) } function k(p) { return p === null ? n(p) : p === 93 ? (e.consume(p), w) : B(p) ? (a = k, P(p)) : (e.consume(p), k) } function w(p) { return p === 93 ? (e.consume(p), y) : k(p) } function y(p) { return p === 62 ? C(p) : p === 93 ? (e.consume(p), y) : k(p) } function S(p) { return p === null || p === 62 ? C(p) : B(p) ? (a = S, P(p)) : (e.consume(p), S) } function I(p) { return p === null ? n(p) : p === 63 ? (e.consume(p), M) : B(p) ? (a = I, P(p)) : (e.consume(p), I) } function M(p) { return p === 62 ? C(p) : I(p) } function F(p) { return ie(p) ? (e.consume(p), v) : n(p) } function v(p) { return p === 45 || le(p) ? (e.consume(p), v) : O(p) } function O(p) { return B(p) ? (a = O, P(p)) : j(p) ? (e.consume(p), O) : C(p) } function K(p) { return p === 45 || le(p) ? (e.consume(p), K) : p === 47 || p === 62 || Q(p) ? E(p) : n(p) } function E(p) { return p === 47 ? (e.consume(p), C) : p === 58 || p === 95 || ie(p) ? (e.consume(p), b) : B(p) ? (a = E, P(p)) : j(p) ? (e.consume(p), E) : C(p) } function b(p) { return p === 45 || p === 46 || p === 58 || p === 95 || le(p) ? (e.consume(p), b) : T(p) } function T(p) { return p === 61 ? (e.consume(p), L) : B(p) ? (a = T, P(p)) : j(p) ? (e.consume(p), T) : E(p) } function L(p) { return p === null || p === 60 || p === 61 || p === 62 || p === 96 ? n(p) : p === 34 || p === 39 ? (e.consume(p), o = p, R) : B(p) ? (a = L, P(p)) : j(p) ? (e.consume(p), L) : (e.consume(p), N) } function R(p) { return p === o ? (e.consume(p), o = void 0, V) : p === null ? n(p) : B(p) ? (a = R, P(p)) : (e.consume(p), R) } function N(p) { return p === null || p === 34 || p === 39 || p === 60 || p === 61 || p === 96 ? n(p) : p === 47 || p === 62 || Q(p) ? E(p) : (e.consume(p), N) } function V(p) { return p === 47 || p === 62 || Q(p) ? E(p) : n(p) } function C(p) { return p === 62 ? (e.consume(p), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(p) } function P(p) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), _ } function _(p) { return j(p) ? q(e, Z, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(p) : Z(p) } function Z(p) { return e.enter("htmlTextData"), a(p) } } const hn = { name: "labelEnd", resolveAll: pl, resolveTo: ml, tokenize: gl }, dl = { tokenize: bl }, hl = { tokenize: yl }, fl = { tokenize: vl }; function pl(e) { let t = -1; const n = []; for (; ++t < e.length;) { const i = e[t][1]; if (n.push(e[t]), i.type === "labelImage" || i.type === "labelLink" || i.type === "labelEnd") { const o = i.type === "labelImage" ? 4 : 2; i.type = "data", t += o } } return e.length !== n.length && ce(e, 0, e.length, n), e } function ml(e, t) { let n = e.length, i = 0, o, r, a, l; for (; n--;)if (o = e[n][1], r) { if (o.type === "link" || o.type === "labelLink" && o._inactive) break; e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0) } else if (a) { if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (r = n, o.type !== "labelLink")) { i = 2; break } } else o.type === "labelEnd" && (a = n); const u = { type: e[r][1].type === "labelLink" ? "link" : "image", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }, s = { type: "label", start: { ...e[r][1].start }, end: { ...e[a][1].end } }, c = { type: "labelText", start: { ...e[r + i + 2][1].end }, end: { ...e[a - 2][1].start } }; return l = [["enter", u, t], ["enter", s, t]], l = fe(l, e.slice(r + 1, r + i + 3)), l = fe(l, [["enter", c, t]]), l = fe(l, Ct(t.parser.constructs.insideSpan.null, e.slice(r + i + 4, a - 3), t)), l = fe(l, [["exit", c, t], e[a - 2], e[a - 1], ["exit", s, t]]), l = fe(l, e.slice(a + 1)), l = fe(l, [["exit", u, t]]), ce(e, r, e.length, l), e } function gl(e, t, n) { const i = this; let o = i.events.length, r, a; for (; o--;)if ((i.events[o][1].type === "labelImage" || i.events[o][1].type === "labelLink") && !i.events[o][1]._balanced) { r = i.events[o][1]; break } return l; function l(f) { return r ? r._inactive ? d(f) : (a = i.parser.defined.includes(ye(i.sliceSerialize({ start: r.end, end: i.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(f), e.exit("labelMarker"), e.exit("labelEnd"), u) : n(f) } function u(f) { return f === 40 ? e.attempt(dl, c, a ? c : d)(f) : f === 91 ? e.attempt(hl, c, a ? s : d)(f) : a ? c(f) : d(f) } function s(f) { return e.attempt(fl, c, d)(f) } function c(f) { return t(f) } function d(f) { return r._balanced = !0, n(f) } } function bl(e, t, n) { return i; function i(d) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), o } function o(d) { return Q(d) ? Ze(e, r)(d) : r(d) } function r(d) { return d === 41 ? c(d) : Li(e, a, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d) } function a(d) { return Q(d) ? Ze(e, u)(d) : c(d) } function l(d) { return n(d) } function u(d) { return d === 34 || d === 39 || d === 40 ? Fi(e, s, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d) } function s(d) { return Q(d) ? Ze(e, c)(d) : c(d) } function c(d) { return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d) } } function yl(e, t, n) { const i = this; return o; function o(l) { return Pi.call(i, e, r, a, "reference", "referenceMarker", "referenceString")(l) } function r(l) { return i.parser.defined.includes(ye(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1))) ? t(l) : n(l) } function a(l) { return n(l) } } function vl(e, t, n) { return i; function i(r) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), o } function o(r) { return r === 93 ? (e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), e.exit("reference"), t) : n(r) } } const kl = { name: "labelStartImage", resolveAll: hn.resolveAll, tokenize: wl }; function wl(e, t, n) { const i = this; return o; function o(l) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(l), e.exit("labelImageMarker"), r } function r(l) { return l === 91 ? (e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelImage"), a) : n(l) } function a(l) { return l === 94 && "_hiddenFootnoteSupport" in i.parser.constructs ? n(l) : t(l) } } const xl = { name: "labelStartLink", resolveAll: hn.resolveAll, tokenize: Il }; function Il(e, t, n) { const i = this; return o; function o(a) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), r } function r(a) { return a === 94 && "_hiddenFootnoteSupport" in i.parser.constructs ? n(a) : t(a) } } const _t = { name: "lineEnding", tokenize: Sl }; function Sl(e, t) { return n; function n(i) { return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), q(e, t, "linePrefix") } } const mt = { name: "thematicBreak", tokenize: Cl }; function Cl(e, t, n) { let i = 0, o; return r; function r(s) { return e.enter("thematicBreak"), a(s) } function a(s) { return o = s, l(s) } function l(s) { return s === o ? (e.enter("thematicBreakSequence"), u(s)) : i >= 3 && (s === null || B(s)) ? (e.exit("thematicBreak"), t(s)) : n(s) } function u(s) { return s === o ? (e.consume(s), i++, u) : (e.exit("thematicBreakSequence"), j(s) ? q(e, l, "whitespace")(s) : l(s)) } } const re = { continuation: { tokenize: Ll }, exit: Fl, name: "list", tokenize: Tl }, El = { partial: !0, tokenize: Dl }, Al = { partial: !0, tokenize: Pl }; function Tl(e, t, n) { const i = this, o = i.events[i.events.length - 1]; let r = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, a = 0; return l; function l(h) { const g = i.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered"); if (g === "listUnordered" ? !i.containerState.marker || h === i.containerState.marker : Xt(h)) { if (i.containerState.type || (i.containerState.type = g, e.enter(g, { _container: !0 })), g === "listUnordered") return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(mt, n, s)(h) : s(h); if (!i.interrupt || h === 49) return e.enter("listItemPrefix"), e.enter("listItemValue"), u(h) } return n(h) } function u(h) { return Xt(h) && ++a < 10 ? (e.consume(h), u) : (!i.interrupt || a < 2) && (i.containerState.marker ? h === i.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), s(h)) : n(h) } function s(h) { return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), i.containerState.marker = i.containerState.marker || h, e.check(lt, i.interrupt ? n : c, e.attempt(El, f, d)) } function c(h) { return i.containerState.initialBlankLine = !0, r++, f(h) } function d(h) { return j(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), f) : n(h) } function f(h) { return i.containerState.size = r + i.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h) } } function Ll(e, t, n) { const i = this; return i.containerState._closeFlow = void 0, e.check(lt, o, r); function o(l) { return i.containerState.furtherBlankLines = i.containerState.furtherBlankLines || i.containerState.initialBlankLine, q(e, t, "listItemIndent", i.containerState.size + 1)(l) } function r(l) { return i.containerState.furtherBlankLines || !j(l) ? (i.containerState.furtherBlankLines = void 0, i.containerState.initialBlankLine = void 0, a(l)) : (i.containerState.furtherBlankLines = void 0, i.containerState.initialBlankLine = void 0, e.attempt(Al, t, a)(l)) } function a(l) { return i.containerState._closeFlow = !0, i.interrupt = void 0, q(e, e.attempt(re, t, n), "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l) } } function Pl(e, t, n) { const i = this; return q(e, o, "listItemIndent", i.containerState.size + 1); function o(r) { const a = i.events[i.events.length - 1]; return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === i.containerState.size ? t(r) : n(r) } } function Fl(e) { e.exit(this.containerState.type) } function Dl(e, t, n) { const i = this; return q(e, o, "listItemPrefixWhitespace", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5); function o(r) { const a = i.events[i.events.length - 1]; return !j(r) && a && a[1].type === "listItemPrefixWhitespace" ? t(r) : n(r) } } const On = { name: "setextUnderline", resolveTo: zl, tokenize: Ml }; function zl(e, t) { let n = e.length, i, o, r; for (; n--;)if (e[n][0] === "enter") { if (e[n][1].type === "content") { i = n; break } e[n][1].type === "paragraph" && (o = n) } else e[n][1].type === "content" && e.splice(n, 1), !r && e[n][1].type === "definition" && (r = n); const a = { type: "setextHeading", start: { ...e[i][1].start }, end: { ...e[e.length - 1][1].end } }; return e[o][1].type = "setextHeadingText", r ? (e.splice(o, 0, ["enter", a, t]), e.splice(r + 1, 0, ["exit", e[i][1], t]), e[i][1].end = { ...e[r][1].end }) : e[i][1] = a, e.push(["exit", a, t]), e } function Ml(e, t, n) { const i = this; let o; return r; function r(s) { let c = i.events.length, d; for (; c--;)if (i.events[c][1].type !== "lineEnding" && i.events[c][1].type !== "linePrefix" && i.events[c][1].type !== "content") { d = i.events[c][1].type === "paragraph"; break } return !i.parser.lazy[i.now().line] && (i.interrupt || d) ? (e.enter("setextHeadingLine"), o = s, a(s)) : n(s) } function a(s) { return e.enter("setextHeadingLineSequence"), l(s) } function l(s) { return s === o ? (e.consume(s), l) : (e.exit("setextHeadingLineSequence"), j(s) ? q(e, u, "lineSuffix")(s) : u(s)) } function u(s) { return s === null || B(s) ? (e.exit("setextHeadingLine"), t(s)) : n(s) } } const _l = { tokenize: Bl }; function Bl(e) { const t = this, n = e.attempt(lt, i, e.attempt(this.parser.constructs.flowInitial, o, q(e, e.attempt(this.parser.constructs.flow, o, e.attempt(Va, o)), "linePrefix"))); return n; function i(r) { if (r === null) { e.consume(r); return } return e.enter("lineEndingBlank"), e.consume(r), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n } function o(r) { if (r === null) { e.consume(r); return } return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), t.currentConstruct = void 0, n } } const Ol = { resolveAll: zi() }, Rl = Di("string"), $l = Di("text"); function Di(e) { return { resolveAll: zi(e === "text" ? Hl : void 0), tokenize: t }; function t(n) { const i = this, o = this.parser.constructs[e], r = n.attempt(o, a, l); return a; function a(c) { return s(c) ? r(c) : l(c) } function l(c) { if (c === null) { n.consume(c); return } return n.enter("data"), n.consume(c), u } function u(c) { return s(c) ? (n.exit("data"), r(c)) : (n.consume(c), u) } function s(c) { if (c === null) return !0; const d = o[c]; let f = -1; if (d) for (; ++f < d.length;) { const h = d[f]; if (!h.previous || h.previous.call(i, i.previous)) return !0 } return !1 } } } function zi(e) { return t; function t(n, i) { let o = -1, r; for (; ++o <= n.length;)r === void 0 ? n[o] && n[o][1].type === "data" && (r = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== r + 2 && (n[r][1].end = n[o - 1][1].end, n.splice(r + 2, o - r - 2), o = r + 2), r = void 0); return e ? e(n, i) : n } } function Hl(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") { const i = e[n - 1][1], o = t.sliceStream(i); let r = o.length, a = -1, l = 0, u; for (; r--;) { const s = o[r]; if (typeof s == "string") { for (a = s.length; s.charCodeAt(a - 1) === 32;)l++, a--; if (a) break; a = -1 } else if (s === -2) u = !0, l++; else if (s !== -1) { r++; break } } if (t._contentTypeTextTrailing && n === e.length && (l = 0), l) { const s = { type: n === e.length || u || l < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: r ? a : i.start._bufferIndex + a, _index: i.start._index + r, line: i.end.line, column: i.end.column - l, offset: i.end.offset - l }, end: { ...i.end } }; i.end = { ...s.start }, i.start.offset === i.end.offset ? Object.assign(i, s) : (e.splice(n, 0, ["enter", s, t], ["exit", s, t]), n += 2) } n++ } return e } const Vl = { 42: re, 43: re, 45: re, 48: re, 49: re, 50: re, 51: re, 52: re, 53: re, 54: re, 55: re, 56: re, 57: re, 62: Ci }, Nl = { 91: qa }, jl = { [-2]: Mt, [-1]: Mt, 32: Mt }, Kl = { 35: Ja, 42: mt, 45: [On, mt], 60: nl, 61: On, 95: mt, 96: _n, 126: _n }, Wl = { 38: Ai, 92: Ei }, ql = { [-5]: _t, [-4]: _t, [-3]: _t, 33: kl, 38: Ai, 42: Jt, 60: [xa, ul], 91: xl, 92: [Ga, Ei], 93: hn, 95: Jt, 96: _a }, Yl = { null: [Jt, Ol] }, Ul = { null: [42, 95] }, Ql = { null: [] }, Gl = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: Ul, contentInitial: Nl, disable: Ql, document: Vl, flow: Kl, flowInitial: jl, insideSpan: Yl, string: Wl, text: ql }, Symbol.toStringTag, { value: "Module" })); function Xl(e, t, n) { let i = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const o = {}, r = []; let a = [], l = []; const u = { attempt: O(F), check: O(v), consume: S, enter: I, exit: M, interrupt: O(v, { interrupt: !0 }) }, s = { code: null, containerState: {}, defineSkip: k, events: [], now: g, parser: e, previous: null, sliceSerialize: f, sliceStream: h, write: d }; let c = t.tokenize.call(s, u); return t.resolveAll && r.push(t), s; function d(T) { return a = fe(a, T), w(), a[a.length - 1] !== null ? [] : (K(t, 0), s.events = Ct(r, s.events, s), s.events) } function f(T, L) { return Zl(h(T), L) } function h(T) { return Jl(a, T) } function g() { const { _bufferIndex: T, _index: L, line: R, column: N, offset: V } = i; return { _bufferIndex: T, _index: L, line: R, column: N, offset: V } } function k(T) { o[T.line] = T.column, b() } function w() { let T; for (; i._index < a.length;) { const L = a[i._index]; if (typeof L == "string") for (T = i._index, i._bufferIndex < 0 && (i._bufferIndex = 0); i._index === T && i._bufferIndex < L.length;)y(L.charCodeAt(i._bufferIndex)); else y(L) } } function y(T) { c = c(T) } function S(T) { B(T) ? (i.line++, i.column = 1, i.offset += T === -3 ? 2 : 1, b()) : T !== -1 && (i.column++, i.offset++), i._bufferIndex < 0 ? i._index++ : (i._bufferIndex++, i._bufferIndex === a[i._index].length && (i._bufferIndex = -1, i._index++)), s.previous = T } function I(T, L) { const R = L || {}; return R.type = T, R.start = g(), s.events.push(["enter", R, s]), l.push(R), R } function M(T) { const L = l.pop(); return L.end = g(), s.events.push(["exit", L, s]), L } function F(T, L) { K(T, L.from) } function v(T, L) { L.restore() } function O(T, L) { return R; function R(N, V, C) { let P, _, Z, p; return Array.isArray(N) ? de(N) : "tokenize" in N ? de([N]) : X(N); function X(ne) { return qe; function qe(Ee) { const $e = Ee !== null && ne[Ee], He = Ee !== null && ne.null, ut = [...Array.isArray($e) ? $e : $e ? [$e] : [], ...Array.isArray(He) ? He : He ? [He] : []]; return de(ut)(Ee) } } function de(ne) { return P = ne, _ = 0, ne.length === 0 ? C : m(ne[_]) } function m(ne) { return qe; function qe(Ee) { return p = E(), Z = ne, ne.partial || (s.currentConstruct = ne), ne.name && s.parser.constructs.disable.null.includes(ne.name) ? Fe() : ne.tokenize.call(L ? Object.assign(Object.create(s), L) : s, u, me, Fe)(Ee) } } function me(ne) { return T(Z, p), V } function Fe(ne) { return p.restore(), ++_ < P.length ? m(P[_]) : C } } } function K(T, L) { T.resolveAll && !r.includes(T) && r.push(T), T.resolve && ce(s.events, L, s.events.length - L, T.resolve(s.events.slice(L), s)), T.resolveTo && (s.events = T.resolveTo(s.events, s)) } function E() { const T = g(), L = s.previous, R = s.currentConstruct, N = s.events.length, V = Array.from(l); return { from: N, restore: C }; function C() { i = T, s.previous = L, s.currentConstruct = R, s.events.length = N, l = V, b() } } function b() { i.line in o && i.column < 2 && (i.column = o[i.line], i.offset += o[i.line] - 1) } } function Jl(e, t) { const n = t.start._index, i = t.start._bufferIndex, o = t.end._index, r = t.end._bufferIndex; let a; if (n === o) a = [e[n].slice(i, r)]; else { if (a = e.slice(n, o), i > -1) { const l = a[0]; typeof l == "string" ? a[0] = l.slice(i) : a.shift() } r > 0 && a.push(e[o].slice(0, r)) } return a } function Zl(e, t) {
    let n = -1; const i = []; let o; for (; ++n < e.length;) {
        const r = e[n]; let a; if (typeof r == "string") a = r; else switch (r) {
            case -5: { a = "\r"; break } case -4: {
                a = `
`; break
            } case -3: {
                a = `\r
`; break
            } case -2: { a = t ? " " : "	"; break } case -1: { if (!t && o) continue; a = " "; break } default: a = String.fromCharCode(r)
        }o = r === -2, i.push(a)
    } return i.join("")
} function es(e) { const i = { constructs: Ii([Gl, ...(e || {}).extensions || []]), content: o(ma), defined: [], document: o(ba), flow: o(_l), lazy: {}, string: o(Rl), text: o($l) }; return i; function o(r) { return a; function a(l) { return Xl(i, r, l) } } } function ts(e) { for (; !Ti(e);); return e } const Rn = /[\0\t\n\r]/g; function ns() { let e = 1, t = "", n = !0, i; return o; function o(r, a, l) { const u = []; let s, c, d, f, h; for (r = t + (typeof r == "string" ? r.toString() : new TextDecoder(a || void 0).decode(r)), d = 0, t = "", n && (r.charCodeAt(0) === 65279 && d++, n = void 0); d < r.length;) { if (Rn.lastIndex = d, s = Rn.exec(r), f = s && s.index !== void 0 ? s.index : r.length, h = r.charCodeAt(f), !s) { t = r.slice(d); break } if (h === 10 && d === f && i) u.push(-3), i = void 0; else switch (i && (u.push(-5), i = void 0), d < f && (u.push(r.slice(d, f)), e += f - d), h) { case 0: { u.push(65533), e++; break } case 9: { for (c = Math.ceil(e / 4) * 4, u.push(-2); e++ < c;)u.push(-1); break } case 10: { u.push(-4), e = 1; break } default: i = !0, e = 1 }d = f + 1 } return l && (i && u.push(-5), t && u.push(t), u.push(null)), u } } const is = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function Mi(e) { return e.replace(is, rs) } function rs(e, t, n) { if (t) return t; if (n.charCodeAt(0) === 35) { const o = n.charCodeAt(1), r = o === 120 || o === 88; return Si(n.slice(r ? 2 : 1), r ? 16 : 10) } return dn(n) || e } function et(e) { return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? $n(e.position) : "start" in e || "end" in e ? $n(e) : "line" in e || "column" in e ? Zt(e) : "" } function Zt(e) { return Hn(e && e.line) + ":" + Hn(e && e.column) } function $n(e) { return Zt(e && e.start) + "-" + Zt(e && e.end) } function Hn(e) { return e && typeof e == "number" ? e : 1 } const _i = {}.hasOwnProperty; function os(e, t, n) { return typeof t != "string" && (n = t, t = void 0), as(n)(ts(es(n).document().write(ns()(e, t, !0)))) } function as(e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: r(xn), autolinkProtocol: E, autolinkEmail: E, atxHeading: r(vn), blockQuote: r(He), characterEscape: E, characterReference: E, codeFenced: r(ut), codeFencedFenceInfo: a, codeFencedFenceMeta: a, codeIndented: r(ut, a), codeText: r(Sr, a), codeTextData: E, data: E, codeFlowValue: E, definition: r(Cr), definitionDestinationString: a, definitionLabelString: a, definitionTitleString: a, emphasis: r(Er), hardBreakEscape: r(kn), hardBreakTrailing: r(kn), htmlFlow: r(wn, a), htmlFlowData: E, htmlText: r(wn, a), htmlTextData: E, image: r(Ar), label: a, link: r(xn), listItem: r(Tr), listItemValue: f, listOrdered: r(In, d), listUnordered: r(In), paragraph: r(Lr), reference: m, referenceString: a, resourceDestinationString: a, resourceTitleString: a, setextHeading: r(vn), strong: r(Pr), thematicBreak: r(Dr) }, exit: { atxHeading: u(), atxHeadingSequence: F, autolink: u(), autolinkEmail: $e, autolinkProtocol: Ee, blockQuote: u(), characterEscapeValue: b, characterReferenceMarkerHexadecimal: Fe, characterReferenceMarkerNumeric: Fe, characterReferenceValue: ne, characterReference: qe, codeFenced: u(w), codeFencedFence: k, codeFencedFenceInfo: h, codeFencedFenceMeta: g, codeFlowValue: b, codeIndented: u(y), codeText: u(V), codeTextData: b, data: b, definition: u(), definitionDestinationString: M, definitionLabelString: S, definitionTitleString: I, emphasis: u(), hardBreakEscape: u(L), hardBreakTrailing: u(L), htmlFlow: u(R), htmlFlowData: b, htmlText: u(N), htmlTextData: b, image: u(P), label: Z, labelText: _, lineEnding: T, link: u(C), listItem: u(), listOrdered: u(), listUnordered: u(), paragraph: u(), referenceString: me, resourceDestinationString: p, resourceTitleString: X, resource: de, setextHeading: u(K), setextHeadingLineSequence: O, setextHeadingText: v, strong: u(), thematicBreak: u() } }; Bi(t, (e || {}).mdastExtensions || []); const n = {}; return i; function i(x) { let A = { type: "root", children: [] }; const $ = { stack: [A], tokenStack: [], config: t, enter: l, exit: s, buffer: a, resume: c, data: n }, W = []; let U = -1; for (; ++U < x.length;)if (x[U][1].type === "listOrdered" || x[U][1].type === "listUnordered") if (x[U][0] === "enter") W.push(U); else { const ge = W.pop(); U = o(x, ge, U) } for (U = -1; ++U < x.length;) { const ge = t[x[U][0]]; _i.call(ge, x[U][1].type) && ge[x[U][1].type].call(Object.assign({ sliceSerialize: x[U][2].sliceSerialize }, $), x[U][1]) } if ($.tokenStack.length > 0) { const ge = $.tokenStack[$.tokenStack.length - 1]; (ge[1] || Vn).call($, void 0, ge[0]) } for (A.position = { start: Ae(x.length > 0 ? x[0][1].start : { line: 1, column: 1, offset: 0 }), end: Ae(x.length > 0 ? x[x.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, U = -1; ++U < t.transforms.length;)A = t.transforms[U](A) || A; return A } function o(x, A, $) { let W = A - 1, U = -1, ge = !1, De, xe, Ye, Ue; for (; ++W <= $;) { const ue = x[W]; switch (ue[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": { ue[0] === "enter" ? U++ : U--, Ue = void 0; break } case "lineEndingBlank": { ue[0] === "enter" && (De && !Ue && !U && !Ye && (Ye = W), Ue = void 0); break } case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: Ue = void 0 }if (!U && ue[0] === "enter" && ue[1].type === "listItemPrefix" || U === -1 && ue[0] === "exit" && (ue[1].type === "listUnordered" || ue[1].type === "listOrdered")) { if (De) { let Ve = W; for (xe = void 0; Ve--;) { const Ie = x[Ve]; if (Ie[1].type === "lineEnding" || Ie[1].type === "lineEndingBlank") { if (Ie[0] === "exit") continue; xe && (x[xe][1].type = "lineEndingBlank", ge = !0), Ie[1].type = "lineEnding", xe = Ve } else if (!(Ie[1].type === "linePrefix" || Ie[1].type === "blockQuotePrefix" || Ie[1].type === "blockQuotePrefixWhitespace" || Ie[1].type === "blockQuoteMarker" || Ie[1].type === "listItemIndent")) break } Ye && (!xe || Ye < xe) && (De._spread = !0), De.end = Object.assign({}, xe ? x[xe][1].start : ue[1].end), x.splice(xe || W, 0, ["exit", De, ue[2]]), W++, $++ } if (ue[1].type === "listItemPrefix") { const Ve = { type: "listItem", _spread: !1, start: Object.assign({}, ue[1].start), end: void 0 }; De = Ve, x.splice(W, 0, ["enter", Ve, ue[2]]), W++, $++, Ye = void 0, Ue = !0 } } } return x[A][1]._spread = ge, $ } function r(x, A) { return $; function $(W) { l.call(this, x(W), W), A && A.call(this, W) } } function a() { this.stack.push({ type: "fragment", children: [] }) } function l(x, A, $) { this.stack[this.stack.length - 1].children.push(x), this.stack.push(x), this.tokenStack.push([A, $ || void 0]), x.position = { start: Ae(A.start), end: void 0 } } function u(x) { return A; function A($) { x && x.call(this, $), s.call(this, $) } } function s(x, A) { const $ = this.stack.pop(), W = this.tokenStack.pop(); if (W) W[0].type !== x.type && (A ? A.call(this, x, W[0]) : (W[1] || Vn).call(this, x, W[0])); else throw new Error("Cannot close `" + x.type + "` (" + et({ start: x.start, end: x.end }) + "): it’s not open"); $.position.end = Ae(x.end) } function c() { return cn(this.stack.pop()) } function d() { this.data.expectingFirstListItemValue = !0 } function f(x) { if (this.data.expectingFirstListItemValue) { const A = this.stack[this.stack.length - 2]; A.start = Number.parseInt(this.sliceSerialize(x), 10), this.data.expectingFirstListItemValue = void 0 } } function h() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.lang = x } function g() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.meta = x } function k() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function w() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.value = x.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function y() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.value = x.replace(/(\r?\n|\r)$/g, "") } function S(x) { const A = this.resume(), $ = this.stack[this.stack.length - 1]; $.label = A, $.identifier = ye(this.sliceSerialize(x)).toLowerCase() } function I() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.title = x } function M() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.url = x } function F(x) { const A = this.stack[this.stack.length - 1]; if (!A.depth) { const $ = this.sliceSerialize(x).length; A.depth = $ } } function v() { this.data.setextHeadingSlurpLineEnding = !0 } function O(x) { const A = this.stack[this.stack.length - 1]; A.depth = this.sliceSerialize(x).codePointAt(0) === 61 ? 1 : 2 } function K() { this.data.setextHeadingSlurpLineEnding = void 0 } function E(x) { const $ = this.stack[this.stack.length - 1].children; let W = $[$.length - 1]; (!W || W.type !== "text") && (W = Fr(), W.position = { start: Ae(x.start), end: void 0 }, $.push(W)), this.stack.push(W) } function b(x) { const A = this.stack.pop(); A.value += this.sliceSerialize(x), A.position.end = Ae(x.end) } function T(x) { const A = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { const $ = A.children[A.children.length - 1]; $.position.end = Ae(x.end), this.data.atHardBreak = void 0; return } !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(A.type) && (E.call(this, x), b.call(this, x)) } function L() { this.data.atHardBreak = !0 } function R() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.value = x } function N() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.value = x } function V() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.value = x } function C() { const x = this.stack[this.stack.length - 1]; if (this.data.inReference) { const A = this.data.referenceType || "shortcut"; x.type += "Reference", x.referenceType = A, delete x.url, delete x.title } else delete x.identifier, delete x.label; this.data.referenceType = void 0 } function P() { const x = this.stack[this.stack.length - 1]; if (this.data.inReference) { const A = this.data.referenceType || "shortcut"; x.type += "Reference", x.referenceType = A, delete x.url, delete x.title } else delete x.identifier, delete x.label; this.data.referenceType = void 0 } function _(x) { const A = this.sliceSerialize(x), $ = this.stack[this.stack.length - 2]; $.label = Mi(A), $.identifier = ye(A).toLowerCase() } function Z() { const x = this.stack[this.stack.length - 1], A = this.resume(), $ = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, $.type === "link") { const W = x.children; $.children = W } else $.alt = A } function p() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.url = x } function X() { const x = this.resume(), A = this.stack[this.stack.length - 1]; A.title = x } function de() { this.data.inReference = void 0 } function m() { this.data.referenceType = "collapsed" } function me(x) { const A = this.resume(), $ = this.stack[this.stack.length - 1]; $.label = A, $.identifier = ye(this.sliceSerialize(x)).toLowerCase(), this.data.referenceType = "full" } function Fe(x) { this.data.characterReferenceType = x.type } function ne(x) { const A = this.sliceSerialize(x), $ = this.data.characterReferenceType; let W; $ ? (W = Si(A, $ === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : W = dn(A); const U = this.stack[this.stack.length - 1]; U.value += W } function qe(x) { const A = this.stack.pop(); A.position.end = Ae(x.end) } function Ee(x) { b.call(this, x); const A = this.stack[this.stack.length - 1]; A.url = this.sliceSerialize(x) } function $e(x) { b.call(this, x); const A = this.stack[this.stack.length - 1]; A.url = "mailto:" + this.sliceSerialize(x) } function He() { return { type: "blockquote", children: [] } } function ut() { return { type: "code", lang: null, meta: null, value: "" } } function Sr() { return { type: "inlineCode", value: "" } } function Cr() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function Er() { return { type: "emphasis", children: [] } } function vn() { return { type: "heading", depth: 0, children: [] } } function kn() { return { type: "break" } } function wn() { return { type: "html", value: "" } } function Ar() { return { type: "image", title: null, url: "", alt: null } } function xn() { return { type: "link", title: null, url: "", children: [] } } function In(x) { return { type: "list", ordered: x.type === "listOrdered", start: null, spread: x._spread, children: [] } } function Tr(x) { return { type: "listItem", spread: x._spread, checked: null, children: [] } } function Lr() { return { type: "paragraph", children: [] } } function Pr() { return { type: "strong", children: [] } } function Fr() { return { type: "text", value: "" } } function Dr() { return { type: "thematicBreak" } } } function Ae(e) { return { line: e.line, column: e.column, offset: e.offset } } function Bi(e, t) { let n = -1; for (; ++n < t.length;) { const i = t[n]; Array.isArray(i) ? Bi(e, i) : ls(e, i) } } function ls(e, t) { let n; for (n in t) if (_i.call(t, n)) switch (n) { case "canContainEols": { const i = t[n]; i && e[n].push(...i); break } case "transforms": { const i = t[n]; i && e[n].push(...i); break } case "enter": case "exit": { const i = t[n]; i && Object.assign(e[n], i); break } } } function Vn(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + et({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + et({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + et({ start: t.start, end: t.end }) + ") is still open") } function Oi(e) { const t = this; t.parser = n; function n(i) { return os(i, { ...t.data("settings"), ...e, extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] }) } } const Nn = {}.hasOwnProperty; function ss(e, t) { const n = t || {}; function i(o, ...r) { let a = i.invalid; const l = i.handlers; if (o && Nn.call(o, e)) { const u = String(o[e]); a = Nn.call(l, u) ? l[u] : i.unknown } if (a) return a.call(this, o, ...r) } return i.handlers = n.handlers || {}, i.invalid = n.invalid, i.unknown = n.unknown, i } const us = {}.hasOwnProperty; function Ri(e, t) { let n = -1, i; if (t.extensions) for (; ++n < t.extensions.length;)Ri(e, t.extensions[n]); for (i in t) if (us.call(t, i)) switch (i) { case "extensions": break; case "unsafe": { jn(e[i], t[i]); break } case "join": { jn(e[i], t[i]); break } case "handlers": { cs(e[i], t[i]); break } default: e.options[i] = t[i] }return e } function jn(e, t) { t && e.push(...t) } function cs(e, t) { t && Object.assign(e, t) } function ds(e, t, n, i) { const o = n.enter("blockquote"), r = n.createTracker(i); r.move("> "), r.shift(2); const a = n.indentLines(n.containerFlow(e, r.current()), hs); return o(), a } function hs(e, t, n) { return ">" + (n ? "" : " ") + e } function $i(e, t) { return Kn(e, t.inConstruct, !0) && !Kn(e, t.notInConstruct, !1) } function Kn(e, t, n) { if (typeof t == "string" && (t = [t]), !t || t.length === 0) return n; let i = -1; for (; ++i < t.length;)if (e.includes(t[i])) return !0; return !1 } function Wn(e, t, n, i) {
    let o = -1; for (; ++o < n.unsafe.length;)if (n.unsafe[o].character === `
`&& $i(n.stack, n.unsafe[o])) return /[ \t]/.test(i.before) ? "" : " "; return `\\
`} function fs(e, t) { const n = String(e); let i = n.indexOf(t), o = i, r = 0, a = 0; if (typeof t != "string") throw new TypeError("Expected substring"); for (; i !== -1;)i === o ? ++r > a && (a = r) : r = 1, o = i + t.length, i = n.indexOf(t, o); return a } function en(e, t) { return !!(t.options.fences === !1 && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) } function ps(e) { const t = e.options.fence || "`"; if (t !== "`" && t !== "~") throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t } function ms(e, t, n, i) {
    const o = ps(n), r = e.value || "", a = o === "`" ? "GraveAccent" : "Tilde"; if (en(e, n)) { const d = n.enter("codeIndented"), f = n.indentLines(r, gs); return d(), f } const l = n.createTracker(i), u = o.repeat(Math.max(fs(r, o) + 1, 3)), s = n.enter("codeFenced"); let c = l.move(u); if (e.lang) { const d = n.enter(`codeFencedLang${a}`); c += l.move(n.safe(e.lang, { before: c, after: " ", encode: ["`"], ...l.current() })), d() } if (e.lang && e.meta) {
        const d = n.enter(`codeFencedMeta${a}`); c += l.move(" "), c += l.move(n.safe(e.meta, {
            before: c, after: `
`, encode: ["`"], ...l.current()
        })), d()
    } return c += l.move(`
`), r && (c += l.move(r + `
`)), c += l.move(u), s(), c
} function gs(e, t, n) { return (n ? "" : "    ") + e } function fn(e) { const t = e.options.quote || '"'; if (t !== '"' && t !== "'") throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function bs(e, t, n, i) {
    const o = fn(n), r = o === '"' ? "Quote" : "Apostrophe", a = n.enter("definition"); let l = n.enter("label"); const u = n.createTracker(i); let s = u.move("["); return s += u.move(n.safe(n.associationId(e), { before: s, after: "]", ...u.current() })), s += u.move("]: "), l(), !e.url || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), s += u.move("<"), s += u.move(n.safe(e.url, { before: s, after: ">", ...u.current() })), s += u.move(">")) : (l = n.enter("destinationRaw"), s += u.move(n.safe(e.url, {
        before: s, after: e.title ? " " : `
`, ...u.current()
    }))), l(), e.title && (l = n.enter(`title${r}`), s += u.move(" " + o), s += u.move(n.safe(e.title, { before: s, after: o, ...u.current() })), s += u.move(o), l()), a(), s
} function ys(e) { const t = e.options.emphasis || "*"; if (t !== "*" && t !== "_") throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t } function Le(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function vt(e, t, n) { const i = We(e), o = We(t); return i === void 0 ? o === void 0 ? n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : o === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : i === 1 ? o === void 0 ? { inside: !1, outside: !1 } : o === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : o === void 0 ? { inside: !1, outside: !1 } : o === 1 ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } Hi.peek = vs; function Hi(e, t, n, i) { const o = ys(n), r = n.enter("emphasis"), a = n.createTracker(i), l = a.move(o); let u = a.move(n.containerPhrasing(e, { after: o, before: l, ...a.current() })); const s = u.charCodeAt(0), c = vt(i.before.charCodeAt(i.before.length - 1), s, o); c.inside && (u = Le(s) + u.slice(1)); const d = u.charCodeAt(u.length - 1), f = vt(i.after.charCodeAt(0), d, o); f.inside && (u = u.slice(0, -1) + Le(d)); const h = a.move(o); return r(), n.attentionEncodeSurroundingInfo = { after: f.outside, before: c.outside }, l + u + h } function vs(e, t, n) { return n.options.emphasis || "*" } const Et = (function (e) { if (e == null) return Is; if (typeof e == "function") return At(e); if (typeof e == "object") return Array.isArray(e) ? ks(e) : ws(e); if (typeof e == "string") return xs(e); throw new Error("Expected function, string, or object as test") }); function ks(e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = Et(e[n]); return At(i); function i(...o) { let r = -1; for (; ++r < t.length;)if (t[r].apply(this, o)) return !0; return !1 } } function ws(e) { const t = e; return At(n); function n(i) { const o = i; let r; for (r in e) if (o[r] !== t[r]) return !1; return !0 } } function xs(e) { return At(t); function t(n) { return n && n.type === e } } function At(e) { return t; function t(n, i, o) { return !!(Ss(n) && e.call(this, n, typeof i == "number" ? i : void 0, o || void 0)) } } function Is() { return !0 } function Ss(e) { return e !== null && typeof e == "object" && "type" in e } const Vi = [], Cs = !0, tn = !1, Es = "skip"; function Ni(e, t, n, i) { let o; typeof t == "function" && typeof n != "function" ? (i = n, n = t) : o = t; const r = Et(o), a = i ? -1 : 1; l(e, void 0, [])(); function l(u, s, c) { const d = u && typeof u == "object" ? u : {}; if (typeof d.type == "string") { const h = typeof d.tagName == "string" ? d.tagName : typeof d.name == "string" ? d.name : void 0; Object.defineProperty(f, "name", { value: "node (" + (u.type + (h ? "<" + h + ">" : "")) + ")" }) } return f; function f() { let h = Vi, g, k, w; if ((!t || r(u, s, c[c.length - 1] || void 0)) && (h = As(n(u, c)), h[0] === tn)) return h; if ("children" in u && u.children) { const y = u; if (y.children && h[0] !== Es) for (k = (i ? y.children.length : -1) + a, w = c.concat(y); k > -1 && k < y.children.length;) { const S = y.children[k]; if (g = l(S, k, w)(), g[0] === tn) return g; k = typeof g[1] == "number" ? g[1] : k + a } } return h } } } function As(e) { return Array.isArray(e) ? e : typeof e == "number" ? [Cs, e] : e == null ? Vi : [e] } function ji(e, t, n, i) { let o, r, a; typeof t == "function" && typeof n != "function" ? (r = void 0, a = t, o = n) : (r = t, a = n, o = i), Ni(e, r, l, o); function l(u, s) { const c = s[s.length - 1], d = c ? c.children.indexOf(u) : void 0; return a(u, d, c) } } function Ki(e, t) { let n = !1; return ji(e, function (i) { if ("value" in i && /\r?\n|\r/.test(i.value) || i.type === "break") return n = !0, tn }), !!((!e.depth || e.depth < 3) && cn(e) && (t.options.setext || n)) } function Ts(e, t, n, i) {
    const o = Math.max(Math.min(6, e.depth || 1), 1), r = n.createTracker(i); if (Ki(e, n)) {
        const c = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(e, {
            ...r.current(), before: `
`, after: `
`}); return d(), c(), f + `
`+ (o === 1 ? "=" : "-").repeat(f.length - (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1))
    } const a = "#".repeat(o), l = n.enter("headingAtx"), u = n.enter("phrasing"); r.move(a + " "); let s = n.containerPhrasing(e, {
        before: "# ", after: `
`, ...r.current()
    }); return /^[\t ]/.test(s) && (s = Le(s.charCodeAt(0)) + s.slice(1)), s = s ? a + " " + s : a, n.options.closeAtx && (s += " " + a), u(), l(), s
} Wi.peek = Ls; function Wi(e) { return e.value || "" } function Ls() { return "<" } qi.peek = Ps; function qi(e, t, n, i) { const o = fn(n), r = o === '"' ? "Quote" : "Apostrophe", a = n.enter("image"); let l = n.enter("label"); const u = n.createTracker(i); let s = u.move("!["); return s += u.move(n.safe(e.alt, { before: s, after: "]", ...u.current() })), s += u.move("]("), l(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), s += u.move("<"), s += u.move(n.safe(e.url, { before: s, after: ">", ...u.current() })), s += u.move(">")) : (l = n.enter("destinationRaw"), s += u.move(n.safe(e.url, { before: s, after: e.title ? " " : ")", ...u.current() }))), l(), e.title && (l = n.enter(`title${r}`), s += u.move(" " + o), s += u.move(n.safe(e.title, { before: s, after: o, ...u.current() })), s += u.move(o), l()), s += u.move(")"), a(), s } function Ps() { return "!" } Yi.peek = Fs; function Yi(e, t, n, i) { const o = e.referenceType, r = n.enter("imageReference"); let a = n.enter("label"); const l = n.createTracker(i); let u = l.move("!["); const s = n.safe(e.alt, { before: u, after: "]", ...l.current() }); u += l.move(s + "]["), a(); const c = n.stack; n.stack = [], a = n.enter("reference"); const d = n.safe(n.associationId(e), { before: u, after: "]", ...l.current() }); return a(), n.stack = c, r(), o === "full" || !s || s !== d ? u += l.move(d + "]") : o === "shortcut" ? u = u.slice(0, -1) : u += l.move("]"), u } function Fs() { return "!" } Ui.peek = Ds; function Ui(e, t, n) { let i = e.value || "", o = "`", r = -1; for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(i);)o += "`"; for (/[^ \r\n]/.test(i) && (/^[ \r\n]/.test(i) && /[ \r\n]$/.test(i) || /^`|`$/.test(i)) && (i = " " + i + " "); ++r < n.unsafe.length;) { const a = n.unsafe[r], l = n.compilePattern(a); let u; if (a.atBreak) for (; u = l.exec(i);) { let s = u.index; i.charCodeAt(s) === 10 && i.charCodeAt(s - 1) === 13 && s--, i = i.slice(0, s) + " " + i.slice(u.index + 1) } } return o + i + o } function Ds() { return "`" } function Qi(e, t) { const n = cn(e); return !!(!t.options.resourceLink && e.url && !e.title && e.children && e.children.length === 1 && e.children[0].type === "text" && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } Gi.peek = zs; function Gi(e, t, n, i) { const o = fn(n), r = o === '"' ? "Quote" : "Apostrophe", a = n.createTracker(i); let l, u; if (Qi(e, n)) { const c = n.stack; n.stack = [], l = n.enter("autolink"); let d = a.move("<"); return d += a.move(n.containerPhrasing(e, { before: d, after: ">", ...a.current() })), d += a.move(">"), l(), n.stack = c, d } l = n.enter("link"), u = n.enter("label"); let s = a.move("["); return s += a.move(n.containerPhrasing(e, { before: s, after: "](", ...a.current() })), s += a.move("]("), u(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), s += a.move("<"), s += a.move(n.safe(e.url, { before: s, after: ">", ...a.current() })), s += a.move(">")) : (u = n.enter("destinationRaw"), s += a.move(n.safe(e.url, { before: s, after: e.title ? " " : ")", ...a.current() }))), u(), e.title && (u = n.enter(`title${r}`), s += a.move(" " + o), s += a.move(n.safe(e.title, { before: s, after: o, ...a.current() })), s += a.move(o), u()), s += a.move(")"), l(), s } function zs(e, t, n) { return Qi(e, n) ? "<" : "[" } Xi.peek = Ms; function Xi(e, t, n, i) { const o = e.referenceType, r = n.enter("linkReference"); let a = n.enter("label"); const l = n.createTracker(i); let u = l.move("["); const s = n.containerPhrasing(e, { before: u, after: "]", ...l.current() }); u += l.move(s + "]["), a(); const c = n.stack; n.stack = [], a = n.enter("reference"); const d = n.safe(n.associationId(e), { before: u, after: "]", ...l.current() }); return a(), n.stack = c, r(), o === "full" || !s || s !== d ? u += l.move(d + "]") : o === "shortcut" ? u = u.slice(0, -1) : u += l.move("]"), u } function Ms() { return "[" } function pn(e) { const t = e.options.bullet || "*"; if (t !== "*" && t !== "+" && t !== "-") throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function _s(e) { const t = pn(e), n = e.options.bulletOther; if (!n) return t === "*" ? "-" : "*"; if (n !== "*" && n !== "+" && n !== "-") throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n } function Bs(e) { const t = e.options.bulletOrdered || "."; if (t !== "." && t !== ")") throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t } function Ji(e) { const t = e.options.rule || "*"; if (t !== "*" && t !== "-" && t !== "_") throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } function Os(e, t, n, i) { const o = n.enter("list"), r = n.bulletCurrent; let a = e.ordered ? Bs(n) : pn(n); const l = e.ordered ? a === "." ? ")" : "." : _s(n); let u = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1; if (!e.ordered) { const c = e.children ? e.children[0] : void 0; if ((a === "*" || a === "-") && c && (!c.children || !c.children[0]) && n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), Ji(n) === a && c) { let d = -1; for (; ++d < e.children.length;) { const f = e.children[d]; if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") { u = !0; break } } } } u && (a = l), n.bulletCurrent = a; const s = n.containerFlow(e, i); return n.bulletLastUsed = a, n.bulletCurrent = r, o(), s } function Rs(e) { const t = e.options.listItemIndent || "one"; if (t !== "tab" && t !== "one" && t !== "mixed") throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t } function $s(e, t, n, i) { const o = Rs(n); let r = n.bulletCurrent || pn(n); t && t.type === "list" && t.ordered && (r = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + r); let a = r.length + 1; (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4); const l = n.createTracker(i); l.move(r + " ".repeat(a - r.length)), l.shift(a); const u = n.enter("listItem"), s = n.indentLines(n.containerFlow(e, l.current()), c); return u(), s; function c(d, f, h) { return f ? (h ? "" : " ".repeat(a)) + d : (h ? r : r + " ".repeat(a - r.length)) + d } } function Hs(e, t, n, i) { const o = n.enter("paragraph"), r = n.enter("phrasing"), a = n.containerPhrasing(e, i); return r(), o(), a } const Vs = Et(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function Ns(e, t, n, i) { return (e.children.some(function (a) { return Vs(a) }) ? n.containerPhrasing : n.containerFlow).call(n, e, i) } function js(e) { const t = e.options.strong || "*"; if (t !== "*" && t !== "_") throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t } Zi.peek = Ks; function Zi(e, t, n, i) { const o = js(n), r = n.enter("strong"), a = n.createTracker(i), l = a.move(o + o); let u = a.move(n.containerPhrasing(e, { after: o, before: l, ...a.current() })); const s = u.charCodeAt(0), c = vt(i.before.charCodeAt(i.before.length - 1), s, o); c.inside && (u = Le(s) + u.slice(1)); const d = u.charCodeAt(u.length - 1), f = vt(i.after.charCodeAt(0), d, o); f.inside && (u = u.slice(0, -1) + Le(d)); const h = a.move(o + o); return r(), n.attentionEncodeSurroundingInfo = { after: f.outside, before: c.outside }, l + u + h } function Ks(e, t, n) { return n.options.strong || "*" } function Ws(e, t, n, i) { return n.safe(e.value, i) } function qs(e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t } function Ys(e, t, n) { const i = (Ji(n) + (n.options.ruleSpaces ? " " : "")).repeat(qs(n)); return n.options.ruleSpaces ? i.slice(0, -1) : i } const mn = { blockquote: ds, break: Wn, code: ms, definition: bs, emphasis: Hi, hardBreak: Wn, heading: Ts, html: Wi, image: qi, imageReference: Yi, inlineCode: Ui, link: Gi, linkReference: Xi, list: Os, listItem: $s, paragraph: Hs, root: Ns, strong: Zi, text: Ws, thematicBreak: Ys }, Us = [Qs]; function Qs(e, t, n, i) { if (t.type === "code" && en(t, i) && (e.type === "list" || e.type === t.type && en(e, i))) return !1; if ("spread" in n && typeof n.spread == "boolean") return e.type === "paragraph" && (e.type === t.type || t.type === "definition" || t.type === "heading" && Ki(t, i)) ? void 0 : n.spread ? 1 : 0 } const Me = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"], Gs = [{ character: "	", after: "[\\r\\n]", inConstruct: "phrasing" }, { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" }, { character: "	", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] }, { character: "\r", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde", "codeFencedMetaGraveAccent", "codeFencedMetaTilde", "destinationLiteral", "headingAtx"] }, {
    character: `
`, inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde", "codeFencedMetaGraveAccent", "codeFencedMetaTilde", "destinationLiteral", "headingAtx"]
}, { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" }, { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" }, { character: " ", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] }, { character: "!", after: "\\[", inConstruct: "phrasing", notInConstruct: Me }, { character: '"', inConstruct: "titleQuote" }, { atBreak: !0, character: "#" }, {
    character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)`}, { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" }, { character: "'", inConstruct: "titleApostrophe" }, { character: "(", inConstruct: "destinationRaw" }, { before: "\\]", character: "(", inConstruct: "phrasing", notInConstruct: Me }, { atBreak: !0, before: "\\d+", character: ")" }, { character: ")", inConstruct: "destinationRaw" }, {
    atBreak: !0, character: "*", after: `(?:[ 	\r
*])`}, { character: "*", inConstruct: "phrasing", notInConstruct: Me }, {
    atBreak: !0, character: "+", after: `(?:[ 	\r
])`}, {
    atBreak: !0, character: "-", after: `(?:[ 	\r
-])`}, {
    atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)`}, { atBreak: !0, character: "<", after: "[!/?A-Za-z]" }, { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing", notInConstruct: Me }, { character: "<", inConstruct: "destinationLiteral" }, { atBreak: !0, character: "=" }, { atBreak: !0, character: ">" }, { character: ">", inConstruct: "destinationLiteral" }, { atBreak: !0, character: "[" }, { character: "[", inConstruct: "phrasing", notInConstruct: Me }, { character: "[", inConstruct: ["label", "reference"] }, { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" }, { character: "]", inConstruct: ["label", "reference"] }, { atBreak: !0, character: "_" }, { character: "_", inConstruct: "phrasing", notInConstruct: Me }, { atBreak: !0, character: "`" }, { character: "`", inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"] }, { character: "`", inConstruct: "phrasing", notInConstruct: Me }, { atBreak: !0, character: "~" }]; function Xs(e) { return e.label || !e.identifier ? e.label || "" : Mi(e.identifier) } function Js(e) { if (!e._compiled) { const t = (e.atBreak ? "[\\r\\n][\\t ]*" : "") + (e.before ? "(?:" + e.before + ")" : ""); e._compiled = new RegExp((t ? "(" + t + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(e.character) ? "\\" : "") + e.character + (e.after ? "(?:" + e.after + ")" : ""), "g") } return e._compiled } function Zs(e, t, n) {
    const i = t.indexStack, o = e.children || [], r = []; let a = -1, l = n.before, u; i.push(-1); let s = t.createTracker(n); for (; ++a < o.length;) {
        const c = o[a]; let d; if (i[i.length - 1] = a, a + 1 < o.length) { let g = t.handle.handlers[o[a + 1].type]; g && g.peek && (g = g.peek), d = g ? g(o[a + 1], e, t, { before: "", after: "", ...s.current() }).charAt(0) : "" } else d = n.after; r.length > 0 && (l === "\r" || l === `
`) && c.type === "html" && (r[r.length - 1] = r[r.length - 1].replace(/(\r?\n|\r)$/, " "), l = " ", s = t.createTracker(n), s.move(r.join(""))); let f = t.handle(c, e, t, { ...s.current(), after: d, before: l }); u && u === f.slice(0, 1) && (f = Le(u.charCodeAt(0)) + f.slice(1)); const h = t.attentionEncodeSurroundingInfo; t.attentionEncodeSurroundingInfo = void 0, u = void 0, h && (r.length > 0 && h.before && l === r[r.length - 1].slice(-1) && (r[r.length - 1] = r[r.length - 1].slice(0, -1) + Le(l.charCodeAt(0))), h.after && (u = d)), s.move(f), r.push(f), l = f.slice(-1)
    } return i.pop(), r.join("")
} function eu(e, t, n) {
    const i = t.indexStack, o = e.children || [], r = t.createTracker(n), a = []; let l = -1; for (i.push(-1); ++l < o.length;) {
        const u = o[l]; i[i.length - 1] = l, a.push(r.move(t.handle(u, e, t, {
            before: `
`, after: `
`, ...r.current()
        }))), u.type !== "list" && (t.bulletLastUsed = void 0), l < o.length - 1 && a.push(r.move(tu(u, o[l + 1], e, t)))
    } return i.pop(), a.join("")
} function tu(e, t, n, i) {
    let o = i.join.length; for (; o--;) {
        const r = i.join[o](e, t, n, i); if (r === !0 || r === 1) break; if (typeof r == "number") return `
`.repeat(1 + r); if (r === !1) return `

<!---->

`} return `

`} const nu = /\r?\n|\r/g; function iu(e, t) { const n = []; let i = 0, o = 0, r; for (; r = nu.exec(e);)a(e.slice(i, r.index)), n.push(r[0]), i = r.index + r[0].length, o++; return a(e.slice(i)), n.join(""); function a(l) { n.push(t(l, o, !l)) } } function ru(e, t, n) { const i = (n.before || "") + (t || "") + (n.after || ""), o = [], r = [], a = {}; let l = -1; for (; ++l < e.unsafe.length;) { const c = e.unsafe[l]; if (!$i(e.stack, c)) continue; const d = e.compilePattern(c); let f; for (; f = d.exec(i);) { const h = "before" in c || !!c.atBreak, g = "after" in c, k = f.index + (h ? f[1].length : 0); o.includes(k) ? (a[k].before && !h && (a[k].before = !1), a[k].after && !g && (a[k].after = !1)) : (o.push(k), a[k] = { before: h, after: g }) } } o.sort(ou); let u = n.before ? n.before.length : 0; const s = i.length - (n.after ? n.after.length : 0); for (l = -1; ++l < o.length;) { const c = o[l]; c < u || c >= s || c + 1 < s && o[l + 1] === c + 1 && a[c].after && !a[c + 1].before && !a[c + 1].after || o[l - 1] === c - 1 && a[c].before && !a[c - 1].before && !a[c - 1].after || (u !== c && r.push(qn(i.slice(u, c), "\\")), u = c, /[!-/:-@[-`{-~]/.test(i.charAt(c)) && (!n.encode || !n.encode.includes(i.charAt(c))) ? r.push("\\") : (r.push(Le(i.charCodeAt(c))), u++)) } return r.push(qn(i.slice(u, s), n.after)), r.join("") } function ou(e, t) { return e - t } function qn(e, t) { const n = /\\(?=[!-/:-@[-`{-~])/g, i = [], o = [], r = e + t; let a = -1, l = 0, u; for (; u = n.exec(r);)i.push(u.index); for (; ++a < i.length;)l !== i[a] && o.push(e.slice(l, i[a])), o.push("\\"), l = i[a]; return o.push(e.slice(l)), o.join("") } function au(e) { const t = e || {}, n = t.now || {}; let i = t.lineShift || 0, o = n.line || 1, r = n.column || 1; return { move: u, current: a, shift: l }; function a() { return { now: { line: o, column: r }, lineShift: i } } function l(s) { i += s } function u(s) { const c = s || "", d = c.split(/\r?\n|\r/g), f = d[d.length - 1]; return o += d.length - 1, r = d.length === 1 ? r + f.length : 1 + f.length + i, c } } function lu(e, t) {
    const n = t || {}, i = { associationId: Xs, containerPhrasing: du, containerFlow: hu, createTracker: au, compilePattern: Js, enter: r, handlers: { ...mn }, handle: void 0, indentLines: iu, indexStack: [], join: [...Us], options: {}, safe: fu, stack: [], unsafe: [...Gs] }; Ri(i, n), i.options.tightDefinitions && i.join.push(cu), i.handle = ss("type", { invalid: su, unknown: uu, handlers: i.handlers }); let o = i.handle(e, void 0, i, {
        before: `
`, after: `
`, now: { line: 1, column: 1 }, lineShift: 0
    }); return o && o.charCodeAt(o.length - 1) !== 10 && o.charCodeAt(o.length - 1) !== 13 && (o += `
`), o; function r(a) { return i.stack.push(a), l; function l() { i.stack.pop() } }
} function su(e) { throw new Error("Cannot handle value `" + e + "`, expected node") } function uu(e) { const t = e; throw new Error("Cannot handle unknown node `" + t.type + "`") } function cu(e, t) { if (e.type === "definition" && e.type === t.type) return 0 } function du(e, t) { return Zs(e, this, t) } function hu(e, t) { return eu(e, this, t) } function fu(e, t) { return ru(this, e, t) } function er(e) { const t = this; t.compiler = n; function n(i) { return lu(i, { ...t.data("settings"), ...e, extensions: t.data("toMarkdownExtensions") || [] }) } } function Yn(e) { if (e) throw e } var Bt, Un; function pu() { if (Un) return Bt; Un = 1; var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = function (s) { return typeof Array.isArray == "function" ? Array.isArray(s) : t.call(s) === "[object Array]" }, r = function (s) { if (!s || t.call(s) !== "[object Object]") return !1; var c = e.call(s, "constructor"), d = s.constructor && s.constructor.prototype && e.call(s.constructor.prototype, "isPrototypeOf"); if (s.constructor && !c && !d) return !1; var f; for (f in s); return typeof f > "u" || e.call(s, f) }, a = function (s, c) { n && c.name === "__proto__" ? n(s, c.name, { enumerable: !0, configurable: !0, value: c.newValue, writable: !0 }) : s[c.name] = c.newValue }, l = function (s, c) { if (c === "__proto__") if (e.call(s, c)) { if (i) return i(s, c).value } else return; return s[c] }; return Bt = function u() { var s, c, d, f, h, g, k = arguments[0], w = 1, y = arguments.length, S = !1; for (typeof k == "boolean" && (S = k, k = arguments[1] || {}, w = 2), (k == null || typeof k != "object" && typeof k != "function") && (k = {}); w < y; ++w)if (s = arguments[w], s != null) for (c in s) d = l(k, c), f = l(s, c), k !== f && (S && f && (r(f) || (h = o(f))) ? (h ? (h = !1, g = d && o(d) ? d : []) : g = d && r(d) ? d : {}, a(k, { name: c, newValue: u(S, g, f) })) : typeof f < "u" && a(k, { name: c, newValue: f })); return k }, Bt } var mu = pu(); const Ot = Zr(mu); function nn(e) { if (typeof e != "object" || e === null) return !1; const t = Object.getPrototypeOf(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) } function gu() { const e = [], t = { run: n, use: i }; return t; function n(...o) { let r = -1; const a = o.pop(); if (typeof a != "function") throw new TypeError("Expected function as last argument, not " + a); l(null, ...o); function l(u, ...s) { const c = e[++r]; let d = -1; if (u) { a(u); return } for (; ++d < o.length;)(s[d] === null || s[d] === void 0) && (s[d] = o[d]); o = s, c ? bu(c, l)(...s) : a(null, ...s) } } function i(o) { if (typeof o != "function") throw new TypeError("Expected `middelware` to be a function, not " + o); return e.push(o), t } } function bu(e, t) { let n; return i; function i(...a) { const l = e.length > a.length; let u; l && a.push(o); try { u = e.apply(this, a) } catch (s) { const c = s; if (l && n) throw c; return o(c) } l || (u && u.then && typeof u.then == "function" ? u.then(r, o) : u instanceof Error ? o(u) : r(u)) } function o(a, ...l) { n || (n = !0, t(a, ...l)) } function r(a) { o(null, a) } } class se extends Error { constructor(t, n, i) { super(), typeof n == "string" && (i = n, n = void 0); let o = "", r = {}, a = !1; if (n && ("line" in n && "column" in n ? r = { place: n } : "start" in n && "end" in n ? r = { place: n } : "type" in n ? r = { ancestors: [n], place: n.position } : r = { ...n }), typeof t == "string" ? o = t : !r.cause && t && (a = !0, o = t.message, r.cause = t), !r.ruleId && !r.source && typeof i == "string") { const u = i.indexOf(":"); u === -1 ? r.ruleId = i : (r.source = i.slice(0, u), r.ruleId = i.slice(u + 1)) } if (!r.place && r.ancestors && r.ancestors) { const u = r.ancestors[r.ancestors.length - 1]; u && (r.place = u.position) } const l = r.place && "start" in r.place ? r.place.start : r.place; this.ancestors = r.ancestors || void 0, this.cause = r.cause || void 0, this.column = l ? l.column : void 0, this.fatal = void 0, this.file = "", this.message = o, this.line = l ? l.line : void 0, this.name = et(r.place) || "1:1", this.place = r.place || void 0, this.reason = this.message, this.ruleId = r.ruleId || void 0, this.source = r.source || void 0, this.stack = a && r.cause && typeof r.cause.stack == "string" ? r.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0 } } se.prototype.file = ""; se.prototype.name = ""; se.prototype.reason = ""; se.prototype.message = ""; se.prototype.stack = ""; se.prototype.column = void 0; se.prototype.line = void 0; se.prototype.ancestors = void 0; se.prototype.cause = void 0; se.prototype.fatal = void 0; se.prototype.place = void 0; se.prototype.ruleId = void 0; se.prototype.source = void 0; const ve = { basename: yu, dirname: vu, extname: ku, join: wu, sep: "/" }; function yu(e, t) { if (t !== void 0 && typeof t != "string") throw new TypeError('"ext" argument must be a string'); st(e); let n = 0, i = -1, o = e.length, r; if (t === void 0 || t.length === 0 || t.length > e.length) { for (; o--;)if (e.codePointAt(o) === 47) { if (r) { n = o + 1; break } } else i < 0 && (r = !0, i = o + 1); return i < 0 ? "" : e.slice(n, i) } if (t === e) return ""; let a = -1, l = t.length - 1; for (; o--;)if (e.codePointAt(o) === 47) { if (r) { n = o + 1; break } } else a < 0 && (r = !0, a = o + 1), l > -1 && (e.codePointAt(o) === t.codePointAt(l--) ? l < 0 && (i = o) : (l = -1, i = a)); return n === i ? i = a : i < 0 && (i = e.length), e.slice(n, i) } function vu(e) { if (st(e), e.length === 0) return "."; let t = -1, n = e.length, i; for (; --n;)if (e.codePointAt(n) === 47) { if (i) { t = n; break } } else i || (i = !0); return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t) } function ku(e) { st(e); let t = e.length, n = -1, i = 0, o = -1, r = 0, a; for (; t--;) { const l = e.codePointAt(t); if (l === 47) { if (a) { i = t + 1; break } continue } n < 0 && (a = !0, n = t + 1), l === 46 ? o < 0 ? o = t : r !== 1 && (r = 1) : o > -1 && (r = -1) } return o < 0 || n < 0 || r === 0 || r === 1 && o === n - 1 && o === i + 1 ? "" : e.slice(o, n) } function wu(...e) { let t = -1, n; for (; ++t < e.length;)st(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]); return n === void 0 ? "." : xu(n) } function xu(e) { st(e); const t = e.codePointAt(0) === 47; let n = Iu(e, !t); return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n } function Iu(e, t) { let n = "", i = 0, o = -1, r = 0, a = -1, l, u; for (; ++a <= e.length;) { if (a < e.length) l = e.codePointAt(a); else { if (l === 47) break; l = 47 } if (l === 47) { if (!(o === a - 1 || r === 1)) if (o !== a - 1 && r === 2) { if (n.length < 2 || i !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) { if (n.length > 2) { if (u = n.lastIndexOf("/"), u !== n.length - 1) { u < 0 ? (n = "", i = 0) : (n = n.slice(0, u), i = n.length - 1 - n.lastIndexOf("/")), o = a, r = 0; continue } } else if (n.length > 0) { n = "", i = 0, o = a, r = 0; continue } } t && (n = n.length > 0 ? n + "/.." : "..", i = 2) } else n.length > 0 ? n += "/" + e.slice(o + 1, a) : n = e.slice(o + 1, a), i = a - o - 1; o = a, r = 0 } else l === 46 && r > -1 ? r++ : r = -1 } return n } function st(e) { if (typeof e != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const Su = { cwd: Cu }; function Cu() { return "/" } function rn(e) { return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && e.auth === void 0) } function Eu(e) { if (typeof e == "string") e = new URL(e); else if (!rn(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if (e.protocol !== "file:") { const t = new TypeError("The URL must be of scheme file"); throw t.code = "ERR_INVALID_URL_SCHEME", t } return Au(e) } function Au(e) { if (e.hostname !== "") { const i = new TypeError('File URL host must be "localhost" or empty on darwin'); throw i.code = "ERR_INVALID_FILE_URL_HOST", i } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) { const i = t.codePointAt(n + 2); if (i === 70 || i === 102) { const o = new TypeError("File URL path must not include encoded / characters"); throw o.code = "ERR_INVALID_FILE_URL_PATH", o } } return decodeURIComponent(t) } const Rt = ["history", "path", "basename", "stem", "extname", "dirname"]; class Tu { constructor(t) { let n; t ? rn(t) ? n = { path: t } : typeof t == "string" || Lu(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Su.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let i = -1; for (; ++i < Rt.length;) { const r = Rt[i]; r in n && n[r] !== void 0 && n[r] !== null && (this[r] = r === "history" ? [...n[r]] : n[r]) } let o; for (o in n) Rt.includes(o) || (this[o] = n[o]) } get basename() { return typeof this.path == "string" ? ve.basename(this.path) : void 0 } set basename(t) { Ht(t, "basename"), $t(t, "basename"), this.path = ve.join(this.dirname || "", t) } get dirname() { return typeof this.path == "string" ? ve.dirname(this.path) : void 0 } set dirname(t) { Qn(this.basename, "dirname"), this.path = ve.join(t || "", this.basename) } get extname() { return typeof this.path == "string" ? ve.extname(this.path) : void 0 } set extname(t) { if ($t(t, "extname"), Qn(this.dirname, "extname"), t) { if (t.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`"); if (t.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = ve.join(this.dirname, this.stem + (t || "")) } get path() { return this.history[this.history.length - 1] } set path(t) { rn(t) && (t = Eu(t)), Ht(t, "path"), this.path !== t && this.history.push(t) } get stem() { return typeof this.path == "string" ? ve.basename(this.path, this.extname) : void 0 } set stem(t) { Ht(t, "stem"), $t(t, "stem"), this.path = ve.join(this.dirname || "", t + (this.extname || "")) } fail(t, n, i) { const o = this.message(t, n, i); throw o.fatal = !0, o } info(t, n, i) { const o = this.message(t, n, i); return o.fatal = void 0, o } message(t, n, i) { const o = new se(t, n, i); return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o } toString(t) { return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value) } } function $t(e, t) { if (e && e.includes(ve.sep)) throw new Error("`" + t + "` cannot be a path: did not expect `" + ve.sep + "`") } function Ht(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function Qn(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } function Lu(e) { return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e) } const Pu = (function (e) { const i = this.constructor.prototype, o = i[e], r = function () { return o.apply(r, arguments) }; return Object.setPrototypeOf(r, i), r }), Fu = {}.hasOwnProperty; class gn extends Pu { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = gu() } copy() { const t = new gn; let n = -1; for (; ++n < this.attachers.length;) { const i = this.attachers[n]; t.use(...i) } return t.data(Ot(!0, {}, this.namespace)), t } data(t, n) { return typeof t == "string" ? arguments.length === 2 ? (jt("data", this.frozen), this.namespace[t] = n, this) : Fu.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (jt("data", this.frozen), this.namespace = t, this) : this.namespace } freeze() { if (this.frozen) return this; const t = this; for (; ++this.freezeIndex < this.attachers.length;) { const [n, ...i] = this.attachers[this.freezeIndex]; if (i[0] === !1) continue; i[0] === !0 && (i[0] = void 0); const o = n.call(t, ...i); typeof o == "function" && this.transformers.use(o) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(t) { this.freeze(); const n = ct(t), i = this.parser || this.Parser; return Vt("parse", i), i(String(n), n) } process(t, n) { const i = this; return this.freeze(), Vt("process", this.parser || this.Parser), Nt("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o); function o(r, a) { const l = ct(t), u = i.parse(l); i.run(u, l, function (c, d, f) { if (c || !d || !f) return s(c); const h = d, g = i.stringify(h, f); Mu(g) ? f.value = g : f.result = g, s(c, f) }); function s(c, d) { c || !d ? a(c) : r ? r(d) : n(void 0, d) } } } processSync(t) { let n = !1, i; return this.freeze(), Vt("processSync", this.parser || this.Parser), Nt("processSync", this.compiler || this.Compiler), this.process(t, o), Xn("processSync", "process", n), i; function o(r, a) { n = !0, Yn(r), i = a } } run(t, n, i) { Gn(t), this.freeze(); const o = this.transformers; return !i && typeof n == "function" && (i = n, n = void 0), i ? r(void 0, i) : new Promise(r); function r(a, l) { const u = ct(n); o.run(t, u, s); function s(c, d, f) { const h = d || t; c ? l(c) : a ? a(h) : i(void 0, h, f) } } } runSync(t, n) { let i = !1, o; return this.run(t, n, r), Xn("runSync", "run", i), o; function r(a, l) { Yn(a), o = l, i = !0 } } stringify(t, n) { this.freeze(); const i = ct(n), o = this.compiler || this.Compiler; return Nt("stringify", o), Gn(t), o(t, i) } use(t, ...n) { const i = this.attachers, o = this.namespace; if (jt("use", this.frozen), t != null) if (typeof t == "function") u(t, n); else if (typeof t == "object") Array.isArray(t) ? l(t) : a(t); else throw new TypeError("Expected usable value, not `" + t + "`"); return this; function r(s) { if (typeof s == "function") u(s, []); else if (typeof s == "object") if (Array.isArray(s)) { const [c, ...d] = s; u(c, d) } else a(s); else throw new TypeError("Expected usable value, not `" + s + "`") } function a(s) { if (!("plugins" in s) && !("settings" in s)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); l(s.plugins), s.settings && (o.settings = Ot(!0, o.settings, s.settings)) } function l(s) { let c = -1; if (s != null) if (Array.isArray(s)) for (; ++c < s.length;) { const d = s[c]; r(d) } else throw new TypeError("Expected a list of plugins, not `" + s + "`") } function u(s, c) { let d = -1, f = -1; for (; ++d < i.length;)if (i[d][0] === s) { f = d; break } if (f === -1) i.push([s, ...c]); else if (c.length > 0) { let [h, ...g] = c; const k = i[f][1]; nn(k) && nn(h) && (h = Ot(!0, k, h)), i[f] = [s, h, ...g] } } } } const Du = new gn().freeze(); function Vt(e, t) { if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `parser`") } function Nt(e, t) { if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `compiler`") } function jt(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function Gn(e) { if (!nn(e) || typeof e.type != "string") throw new TypeError("Expected node, got `" + e + "`") } function Xn(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function ct(e) { return zu(e) ? e : new Tu(e) } function zu(e) { return !!(e && typeof e == "object" && "message" in e && "messages" in e) } function Mu(e) { return typeof e == "string" || _u(e) } function _u(e) { return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e) } const Jn = Du().use(Oi).use(er).freeze(); function Zn(e, t) { const n = String(e); if (typeof t != "string") throw new TypeError("Expected character"); let i = 0, o = n.indexOf(t); for (; o !== -1;)i++, o = n.indexOf(t, o + t.length); return i } function Bu(e) { if (typeof e != "string") throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } function Ou(e, t, n) { const o = Et((n || {}).ignore || []), r = Ru(t); let a = -1; for (; ++a < r.length;)Ni(e, "text", l); function l(s, c) { let d = -1, f; for (; ++d < c.length;) { const h = c[d], g = f ? f.children : void 0; if (o(h, g ? g.indexOf(h) : void 0, f)) return; f = h } if (f) return u(s, c) } function u(s, c) { const d = c[c.length - 1], f = r[a][0], h = r[a][1]; let g = 0; const w = d.children.indexOf(s); let y = !1, S = []; f.lastIndex = 0; let I = f.exec(s.value); for (; I;) { const M = I.index, F = { index: I.index, input: I.input, stack: [...c, s] }; let v = h(...I, F); if (typeof v == "string" && (v = v.length > 0 ? { type: "text", value: v } : void 0), v === !1 ? f.lastIndex = M + 1 : (g !== M && S.push({ type: "text", value: s.value.slice(g, M) }), Array.isArray(v) ? S.push(...v) : v && S.push(v), g = M + I[0].length, y = !0), !f.global) break; I = f.exec(s.value) } return y ? (g < s.value.length && S.push({ type: "text", value: s.value.slice(g) }), d.children.splice(w, 1, ...S)) : S = [s], w + S.length } } function Ru(e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let i = -1; for (; ++i < n.length;) { const o = n[i]; t.push([$u(o[0]), Hu(o[1])]) } return t } function $u(e) { return typeof e == "string" ? new RegExp(Bu(e), "g") : e } function Hu(e) { return typeof e == "function" ? e : function () { return e } } const Kt = "phrasing", Wt = ["autolink", "link", "image", "label"]; function Vu() { return { transforms: [Uu], enter: { literalAutolink: ju, literalAutolinkEmail: qt, literalAutolinkHttp: qt, literalAutolinkWww: qt }, exit: { literalAutolink: Yu, literalAutolinkEmail: qu, literalAutolinkHttp: Ku, literalAutolinkWww: Wu } } } function Nu() { return { unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: Kt, notInConstruct: Wt }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: Kt, notInConstruct: Wt }, { character: ":", before: "[ps]", after: "\\/", inConstruct: Kt, notInConstruct: Wt }] } } function ju(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function qt(e) { this.config.enter.autolinkProtocol.call(this, e) } function Ku(e) { this.config.exit.autolinkProtocol.call(this, e) } function Wu(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function qu(e) { this.config.exit.autolinkEmail.call(this, e) } function Yu(e) { this.exit(e) } function Uu(e) { Ou(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Qu], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), Gu]], { ignore: ["link", "linkReference"] }) } function Qu(e, t, n, i, o) { let r = ""; if (!tr(o) || (/^w/i.test(t) && (n = t + n, t = "", r = "http://"), !Xu(n))) return !1; const a = Ju(n + i); if (!a[0]) return !1; const l = { type: "link", title: null, url: r + t + a[0], children: [{ type: "text", value: t + a[0] }] }; return a[1] ? [l, { type: "text", value: a[1] }] : l } function Gu(e, t, n, i) { return !tr(i, !0) || /[-\d_]$/.test(n) ? !1 : { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function Xu(e) { const t = e.split("."); return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) } function Ju(e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], i = n.indexOf(")"); const o = Zn(e, "("); let r = Zn(e, ")"); for (; i !== -1 && o > r;)e += n.slice(0, i + 1), n = n.slice(i + 1), i = n.indexOf(")"), r++; return [e, n] } function tr(e, t) { const n = e.input.charCodeAt(e.index - 1); return (e.index === 0 || Re(n) || St(n)) && (!t || n !== 47) } nr.peek = lc; function Zu() { this.buffer() } function ec(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function tc() { this.buffer() } function nc(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function ic(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = ye(this.sliceSerialize(e)).toLowerCase(), n.label = t } function rc(e) { this.exit(e) } function oc(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = ye(this.sliceSerialize(e)).toLowerCase(), n.label = t } function ac(e) { this.exit(e) } function lc() { return "[" } function nr(e, t, n, i) { const o = n.createTracker(i); let r = o.move("[^"); const a = n.enter("footnoteReference"), l = n.enter("reference"); return r += o.move(n.safe(n.associationId(e), { after: "]", before: r })), l(), a(), r += o.move("]"), r } function sc() { return { enter: { gfmFootnoteCallString: Zu, gfmFootnoteCall: ec, gfmFootnoteDefinitionLabelString: tc, gfmFootnoteDefinition: nc }, exit: { gfmFootnoteCallString: ic, gfmFootnoteCall: rc, gfmFootnoteDefinitionLabelString: oc, gfmFootnoteDefinition: ac } } } function uc(e) {
    let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: n, footnoteReference: nr }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] }; function n(i, o, r, a) {
        const l = r.createTracker(a); let u = l.move("[^"); const s = r.enter("footnoteDefinition"), c = r.enter("label"); return u += l.move(r.safe(r.associationId(i), { before: u, after: "]" })), c(), u += l.move("]:"), i.children && i.children.length > 0 && (l.shift(4), u += l.move((t ? `
`: " ") + r.indentLines(r.containerFlow(i, l.current()), t ? ir : cc))), s(), u
    }
} function cc(e, t, n) { return t === 0 ? e : ir(e, t, n) } function ir(e, t, n) { return (n ? "" : "    ") + e } const dc = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; rr.peek = gc; function hc() { return { canContainEols: ["delete"], enter: { strikethrough: pc }, exit: { strikethrough: mc } } } function fc() { return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: dc }], handlers: { delete: rr } } } function pc(e) { this.enter({ type: "delete", children: [] }, e) } function mc(e) { this.exit(e) } function rr(e, t, n, i) { const o = n.createTracker(i), r = n.enter("strikethrough"); let a = o.move("~~"); return a += n.containerPhrasing(e, { ...o.current(), before: a, after: "~" }), a += o.move("~~"), r(), a } function gc() { return "~" } function bc(e) { return e.length } function yc(e, t) {
    const n = t || {}, i = (n.align || []).concat(), o = n.stringLength || bc, r = [], a = [], l = [], u = []; let s = 0, c = -1; for (; ++c < e.length;) { const k = [], w = []; let y = -1; for (e[c].length > s && (s = e[c].length); ++y < e[c].length;) { const S = vc(e[c][y]); if (n.alignDelimiters !== !1) { const I = o(S); w[y] = I, (u[y] === void 0 || I > u[y]) && (u[y] = I) } k.push(S) } a[c] = k, l[c] = w } let d = -1; if (typeof i == "object" && "length" in i) for (; ++d < s;)r[d] = ei(i[d]); else { const k = ei(i); for (; ++d < s;)r[d] = k } d = -1; const f = [], h = []; for (; ++d < s;) { const k = r[d]; let w = "", y = ""; k === 99 ? (w = ":", y = ":") : k === 108 ? w = ":" : k === 114 && (y = ":"); let S = n.alignDelimiters === !1 ? 1 : Math.max(1, u[d] - w.length - y.length); const I = w + "-".repeat(S) + y; n.alignDelimiters !== !1 && (S = w.length + S + y.length, S > u[d] && (u[d] = S), h[d] = S), f[d] = I } a.splice(1, 0, f), l.splice(1, 0, h), c = -1; const g = []; for (; ++c < a.length;) { const k = a[c], w = l[c]; d = -1; const y = []; for (; ++d < s;) { const S = k[d] || ""; let I = "", M = ""; if (n.alignDelimiters !== !1) { const F = u[d] - (w[d] || 0), v = r[d]; v === 114 ? I = " ".repeat(F) : v === 99 ? F % 2 ? (I = " ".repeat(F / 2 + .5), M = " ".repeat(F / 2 - .5)) : (I = " ".repeat(F / 2), M = I) : M = " ".repeat(F) } n.delimiterStart !== !1 && !d && y.push("|"), n.padding !== !1 && !(n.alignDelimiters === !1 && S === "") && (n.delimiterStart !== !1 || d) && y.push(" "), n.alignDelimiters !== !1 && y.push(I), y.push(S), n.alignDelimiters !== !1 && y.push(M), n.padding !== !1 && y.push(" "), (n.delimiterEnd !== !1 || d !== s - 1) && y.push("|") } g.push(n.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")) } return g.join(`
`)
} function vc(e) { return e == null ? "" : String(e) } function ei(e) { const t = typeof e == "string" ? e.codePointAt(0) : 0; return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0 } function kc() { return { enter: { table: wc, tableData: ti, tableHeader: ti, tableRow: Ic }, exit: { codeText: Sc, table: xc, tableData: Yt, tableHeader: Yt, tableRow: Yt } } } function wc(e) { const t = e._align; this.enter({ type: "table", align: t.map(function (n) { return n === "none" ? null : n }), children: [] }, e), this.data.inTable = !0 } function xc(e) { this.exit(e), this.data.inTable = void 0 } function Ic(e) { this.enter({ type: "tableRow", children: [] }, e) } function Yt(e) { this.exit(e) } function ti(e) { this.enter({ type: "tableCell", children: [] }, e) } function Sc(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, Cc)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function Cc(e, t) { return t === "|" ? t : e } function Ec(e) {
    const t = e || {}, n = t.tableCellPadding, i = t.tablePipeAlign, o = t.stringLength, r = n ? " " : "|"; return {
        unsafe: [{ character: "\r", inConstruct: "tableCell" }, {
            character: `
`, inConstruct: "tableCell"
        }, { atBreak: !0, character: "|", after: "[	 :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: f, table: a, tableCell: u, tableRow: l }
    }; function a(h, g, k, w) { return s(c(h, k, w), h.align) } function l(h, g, k, w) {
        const y = d(h, k, w), S = s([y]); return S.slice(0, S.indexOf(`
`))
    } function u(h, g, k, w) { const y = k.enter("tableCell"), S = k.enter("phrasing"), I = k.containerPhrasing(h, { ...w, before: r, after: r }); return S(), y(), I } function s(h, g) { return yc(h, { align: g, alignDelimiters: i, padding: n, stringLength: o }) } function c(h, g, k) { const w = h.children; let y = -1; const S = [], I = g.enter("table"); for (; ++y < w.length;)S[y] = d(w[y], g, k); return I(), S } function d(h, g, k) { const w = h.children; let y = -1; const S = [], I = g.enter("tableRow"); for (; ++y < w.length;)S[y] = u(w[y], h, g, k); return I(), S } function f(h, g, k) { let w = mn.inlineCode(h, g, k); return k.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w }
} function Ac() { return { exit: { taskListCheckValueChecked: ni, taskListCheckValueUnchecked: ni, paragraph: Lc } } } function Tc() { return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: Pc } } } function ni(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = e.type === "taskListCheckValueChecked" } function Lc(e) { const t = this.stack[this.stack.length - 2]; if (t && t.type === "listItem" && typeof t.checked == "boolean") { const n = this.stack[this.stack.length - 1]; n.type; const i = n.children[0]; if (i && i.type === "text") { const o = t.children; let r = -1, a; for (; ++r < o.length;) { const l = o[r]; if (l.type === "paragraph") { a = l; break } } a === n && (i.value = i.value.slice(1), i.value.length === 0 ? n.children.shift() : n.position && i.position && typeof i.position.start.offset == "number" && (i.position.start.column++, i.position.start.offset++, n.position.start = Object.assign({}, i.position.start))) } } this.exit(e) } function Pc(e, t, n, i) { const o = e.children[0], r = typeof e.checked == "boolean" && o && o.type === "paragraph", a = "[" + (e.checked ? "x" : " ") + "] ", l = n.createTracker(i); r && l.move(a); let u = mn.listItem(e, t, n, { ...i, ...l.current() }); return r && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, s)), u; function s(c) { return c + a } } function Fc() { return [Vu(), sc(), hc(), kc(), Ac()] } function Dc(e) { return { extensions: [Nu(), uc(e), fc(), Ec(e), Tc()] } } const zc = { tokenize: $c, partial: !0 }, or = { tokenize: Hc, partial: !0 }, ar = { tokenize: Vc, partial: !0 }, lr = { tokenize: Nc, partial: !0 }, Mc = { tokenize: jc, partial: !0 }, sr = { name: "wwwAutolink", tokenize: Oc, previous: cr }, ur = { name: "protocolAutolink", tokenize: Rc, previous: dr }, Ce = { name: "emailAutolink", tokenize: Bc, previous: hr }, we = {}; function _c() { return { text: we } } let _e = 48; for (; _e < 123;)we[_e] = Ce, _e++, _e === 58 ? _e = 65 : _e === 91 && (_e = 97); we[43] = Ce; we[45] = Ce; we[46] = Ce; we[95] = Ce; we[72] = [Ce, ur]; we[104] = [Ce, ur]; we[87] = [Ce, sr]; we[119] = [Ce, sr]; function Bc(e, t, n) { const i = this; let o, r; return a; function a(d) { return !on(d) || !hr.call(i, i.previous) || bn(i.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), l(d)) } function l(d) { return on(d) ? (e.consume(d), l) : d === 64 ? (e.consume(d), u) : n(d) } function u(d) { return d === 46 ? e.check(Mc, c, s)(d) : d === 45 || d === 95 || le(d) ? (r = !0, e.consume(d), u) : c(d) } function s(d) { return e.consume(d), o = !0, u } function c(d) { return r && o && ie(i.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d) } } function Oc(e, t, n) { const i = this; return o; function o(a) { return a !== 87 && a !== 119 || !cr.call(i, i.previous) || bn(i.events) ? n(a) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(zc, e.attempt(or, e.attempt(ar, r), n), n)(a)) } function r(a) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(a) } } function Rc(e, t, n) { const i = this; let o = "", r = !1; return a; function a(d) { return (d === 72 || d === 104) && dr.call(i, i.previous) && !bn(i.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(d), e.consume(d), l) : n(d) } function l(d) { if (ie(d) && o.length < 5) return o += String.fromCodePoint(d), e.consume(d), l; if (d === 58) { const f = o.toLowerCase(); if (f === "http" || f === "https") return e.consume(d), u } return n(d) } function u(d) { return d === 47 ? (e.consume(d), r ? s : (r = !0, u)) : n(d) } function s(d) { return d === null || yt(d) || Q(d) || Re(d) || St(d) ? n(d) : e.attempt(or, e.attempt(ar, c), n)(d) } function c(d) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d) } } function $c(e, t, n) { let i = 0; return o; function o(a) { return (a === 87 || a === 119) && i < 3 ? (i++, e.consume(a), o) : a === 46 && i === 3 ? (e.consume(a), r) : n(a) } function r(a) { return a === null ? n(a) : t(a) } } function Hc(e, t, n) { let i, o, r; return a; function a(s) { return s === 46 || s === 95 ? e.check(lr, u, l)(s) : s === null || Q(s) || Re(s) || s !== 45 && St(s) ? u(s) : (r = !0, e.consume(s), a) } function l(s) { return s === 95 ? i = !0 : (o = i, i = void 0), e.consume(s), a } function u(s) { return o || i || !r ? n(s) : t(s) } } function Vc(e, t) { let n = 0, i = 0; return o; function o(a) { return a === 40 ? (n++, e.consume(a), o) : a === 41 && i < n ? r(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(lr, t, r)(a) : a === null || Q(a) || Re(a) ? t(a) : (e.consume(a), o) } function r(a) { return a === 41 && i++, e.consume(a), o } } function Nc(e, t, n) { return i; function i(l) { return l === 33 || l === 34 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 63 || l === 95 || l === 126 ? (e.consume(l), i) : l === 38 ? (e.consume(l), r) : l === 93 ? (e.consume(l), o) : l === 60 || l === null || Q(l) || Re(l) ? t(l) : n(l) } function o(l) { return l === null || l === 40 || l === 91 || Q(l) || Re(l) ? t(l) : i(l) } function r(l) { return ie(l) ? a(l) : n(l) } function a(l) { return l === 59 ? (e.consume(l), i) : ie(l) ? (e.consume(l), a) : n(l) } } function jc(e, t, n) { return i; function i(r) { return e.consume(r), o } function o(r) { return le(r) ? n(r) : t(r) } } function cr(e) { return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Q(e) } function dr(e) { return !ie(e) } function hr(e) { return !(e === 47 || on(e)) } function on(e) { return e === 43 || e === 45 || e === 46 || e === 95 || le(e) } function bn(e) { let t = e.length, n = !1; for (; t--;) { const i = e[t][1]; if ((i.type === "labelLink" || i.type === "labelImage") && !i._balanced) { n = !0; break } if (i._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } const Kc = { tokenize: Jc, partial: !0 }; function Wc() { return { document: { 91: { name: "gfmFootnoteDefinition", tokenize: Qc, continuation: { tokenize: Gc }, exit: Xc } }, text: { 91: { name: "gfmFootnoteCall", tokenize: Uc }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: qc, resolveTo: Yc } } } } function qc(e, t, n) { const i = this; let o = i.events.length; const r = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []); let a; for (; o--;) { const u = i.events[o][1]; if (u.type === "labelImage") { a = u; break } if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link") break } return l; function l(u) { if (!a || !a._balanced) return n(u); const s = ye(i.sliceSerialize({ start: a.end, end: i.now() })); return s.codePointAt(0) !== 94 || !r.includes(s.slice(1)) ? n(u) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(u), e.exit("gfmFootnoteCallLabelMarker"), t(u)) } } function Yc(e, t) { let n = e.length; for (; n--;)if (e[n][1].type === "labelImage" && e[n][0] === "enter") { e[n][1]; break } e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker"; const i = { type: "gfmFootnoteCall", start: Object.assign({}, e[n + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, o = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[n + 3][1].end), end: Object.assign({}, e[n + 3][1].end) }; o.end.column++, o.end.offset++, o.end._bufferIndex++; const r = { type: "gfmFootnoteCallString", start: Object.assign({}, o.end), end: Object.assign({}, e[e.length - 1][1].start) }, a = { type: "chunkString", contentType: "string", start: Object.assign({}, r.start), end: Object.assign({}, r.end) }, l = [e[n + 1], e[n + 2], ["enter", i, t], e[n + 3], e[n + 4], ["enter", o, t], ["exit", o, t], ["enter", r, t], ["enter", a, t], ["exit", a, t], ["exit", r, t], e[e.length - 2], e[e.length - 1], ["exit", i, t]]; return e.splice(n, e.length - n + 1, ...l), e } function Uc(e, t, n) { const i = this, o = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []); let r = 0, a; return l; function l(d) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), u } function u(d) { return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", s) } function s(d) { if (r > 999 || d === 93 && !a || d === null || d === 91 || Q(d)) return n(d); if (d === 93) { e.exit("chunkString"); const f = e.exit("gfmFootnoteCallString"); return o.includes(ye(i.sliceSerialize(f))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d) } return Q(d) || (a = !0), r++, e.consume(d), d === 92 ? c : s } function c(d) { return d === 91 || d === 92 || d === 93 ? (e.consume(d), r++, s) : s(d) } } function Qc(e, t, n) { const i = this, o = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []); let r, a = 0, l; return u; function u(g) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionLabelMarker"), s } function s(g) { return g === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(g) } function c(g) { if (a > 999 || g === 93 && !l || g === null || g === 91 || Q(g)) return n(g); if (g === 93) { e.exit("chunkString"); const k = e.exit("gfmFootnoteDefinitionLabelString"); return r = ye(i.sliceSerialize(k)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), f } return Q(g) || (l = !0), a++, e.consume(g), g === 92 ? d : c } function d(g) { return g === 91 || g === 92 || g === 93 ? (e.consume(g), a++, c) : c(g) } function f(g) { return g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), o.includes(r) || o.push(r), q(e, h, "gfmFootnoteDefinitionWhitespace")) : n(g) } function h(g) { return t(g) } } function Gc(e, t, n) { return e.check(lt, t, e.attempt(Kc, t, n)) } function Xc(e) { e.exit("gfmFootnoteDefinition") } function Jc(e, t, n) { const i = this; return q(e, o, "gfmFootnoteDefinitionIndent", 5); function o(r) { const a = i.events[i.events.length - 1]; return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(r) : n(r) } } function Zc(e) { let n = (e || {}).singleTilde; const i = { name: "strikethrough", tokenize: r, resolveAll: o }; return n == null && (n = !0), { text: { 126: i }, insideSpan: { null: [i] }, attentionMarkers: { null: [126] } }; function o(a, l) { let u = -1; for (; ++u < a.length;)if (a[u][0] === "enter" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._close) { let s = u; for (; s--;)if (a[s][0] === "exit" && a[s][1].type === "strikethroughSequenceTemporary" && a[s][1]._open && a[u][1].end.offset - a[u][1].start.offset === a[s][1].end.offset - a[s][1].start.offset) { a[u][1].type = "strikethroughSequence", a[s][1].type = "strikethroughSequence"; const c = { type: "strikethrough", start: Object.assign({}, a[s][1].start), end: Object.assign({}, a[u][1].end) }, d = { type: "strikethroughText", start: Object.assign({}, a[s][1].end), end: Object.assign({}, a[u][1].start) }, f = [["enter", c, l], ["enter", a[s][1], l], ["exit", a[s][1], l], ["enter", d, l]], h = l.parser.constructs.insideSpan.null; h && ce(f, f.length, 0, Ct(h, a.slice(s + 1, u), l)), ce(f, f.length, 0, [["exit", d, l], ["enter", a[u][1], l], ["exit", a[u][1], l], ["exit", c, l]]), ce(a, s - 1, u - s + 3, f), u = s + f.length - 2; break } } for (u = -1; ++u < a.length;)a[u][1].type === "strikethroughSequenceTemporary" && (a[u][1].type = "data"); return a } function r(a, l, u) { const s = this.previous, c = this.events; let d = 0; return f; function f(g) { return s === 126 && c[c.length - 1][1].type !== "characterEscape" ? u(g) : (a.enter("strikethroughSequenceTemporary"), h(g)) } function h(g) { const k = We(s); if (g === 126) return d > 1 ? u(g) : (a.consume(g), d++, h); if (d < 2 && !n) return u(g); const w = a.exit("strikethroughSequenceTemporary"), y = We(g); return w._open = !y || y === 2 && !!k, w._close = !k || k === 2 && !!y, l(g) } } } class ed { constructor() { this.map = [] } add(t, n, i) { td(this, t, n, i) } consume(t) { if (this.map.sort(function (r, a) { return r[0] - a[0] }), this.map.length === 0) return; let n = this.map.length; const i = []; for (; n > 0;)n -= 1, i.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0]; i.push(t.slice()), t.length = 0; let o = i.pop(); for (; o;) { for (const r of o) t.push(r); o = i.pop() } this.map.length = 0 } } function td(e, t, n, i) { let o = 0; if (!(n === 0 && i.length === 0)) { for (; o < e.map.length;) { if (e.map[o][0] === t) { e.map[o][1] += n, e.map[o][2].push(...i); return } o += 1 } e.map.push([t, n, i]) } } function nd(e, t) { let n = !1; const i = []; for (; t < e.length;) { const o = e[t]; if (n) { if (o[0] === "enter") o[1].type === "tableContent" && i.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"); else if (o[1].type === "tableContent") { if (e[t - 1][1].type === "tableDelimiterMarker") { const r = i.length - 1; i[r] = i[r] === "left" ? "center" : "right" } } else if (o[1].type === "tableDelimiterRow") break } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0); t += 1 } return i } function id() { return { flow: { null: { name: "table", tokenize: rd, resolveAll: od } } } } function rd(e, t, n) { const i = this; let o = 0, r = 0, a; return l; function l(b) { let T = i.events.length - 1; for (; T > -1;) { const N = i.events[T][1].type; if (N === "lineEnding" || N === "linePrefix") T--; else break } const L = T > -1 ? i.events[T][1].type : null, R = L === "tableHead" || L === "tableRow" ? v : u; return R === v && i.parser.lazy[i.now().line] ? n(b) : R(b) } function u(b) { return e.enter("tableHead"), e.enter("tableRow"), s(b) } function s(b) { return b === 124 || (a = !0, r += 1), c(b) } function c(b) { return b === null ? n(b) : B(b) ? r > 1 ? (r = 0, i.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), h) : n(b) : j(b) ? q(e, c, "whitespace")(b) : (r += 1, a && (a = !1, o += 1), b === 124 ? (e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), a = !0, c) : (e.enter("data"), d(b))) } function d(b) { return b === null || b === 124 || Q(b) ? (e.exit("data"), c(b)) : (e.consume(b), b === 92 ? f : d) } function f(b) { return b === 92 || b === 124 ? (e.consume(b), d) : d(b) } function h(b) { return i.interrupt = !1, i.parser.lazy[i.now().line] ? n(b) : (e.enter("tableDelimiterRow"), a = !1, j(b) ? q(e, g, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(b) : g(b)) } function g(b) { return b === 45 || b === 58 ? w(b) : b === 124 ? (a = !0, e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), k) : F(b) } function k(b) { return j(b) ? q(e, w, "whitespace")(b) : w(b) } function w(b) { return b === 58 ? (r += 1, a = !0, e.enter("tableDelimiterMarker"), e.consume(b), e.exit("tableDelimiterMarker"), y) : b === 45 ? (r += 1, y(b)) : b === null || B(b) ? M(b) : F(b) } function y(b) { return b === 45 ? (e.enter("tableDelimiterFiller"), S(b)) : F(b) } function S(b) { return b === 45 ? (e.consume(b), S) : b === 58 ? (a = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(b), e.exit("tableDelimiterMarker"), I) : (e.exit("tableDelimiterFiller"), I(b)) } function I(b) { return j(b) ? q(e, M, "whitespace")(b) : M(b) } function M(b) { return b === 124 ? g(b) : b === null || B(b) ? !a || o !== r ? F(b) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(b)) : F(b) } function F(b) { return n(b) } function v(b) { return e.enter("tableRow"), O(b) } function O(b) { return b === 124 ? (e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), O) : b === null || B(b) ? (e.exit("tableRow"), t(b)) : j(b) ? q(e, O, "whitespace")(b) : (e.enter("data"), K(b)) } function K(b) { return b === null || b === 124 || Q(b) ? (e.exit("data"), O(b)) : (e.consume(b), b === 92 ? E : K) } function E(b) { return b === 92 || b === 124 ? (e.consume(b), K) : K(b) } } function od(e, t) { let n = -1, i = !0, o = 0, r = [0, 0, 0, 0], a = [0, 0, 0, 0], l = !1, u = 0, s, c, d; const f = new ed; for (; ++n < e.length;) { const h = e[n], g = h[1]; h[0] === "enter" ? g.type === "tableHead" ? (l = !1, u !== 0 && (ii(f, t, u, s, c), c = void 0, u = 0), s = { type: "table", start: Object.assign({}, g.start), end: Object.assign({}, g.end) }, f.add(n, 0, [["enter", s, t]])) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (i = !0, d = void 0, r = [0, 0, 0, 0], a = [0, n + 1, 0, 0], l && (l = !1, c = { type: "tableBody", start: Object.assign({}, g.start), end: Object.assign({}, g.end) }, f.add(n, 0, [["enter", c, t]])), o = g.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : o && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") ? (i = !1, a[2] === 0 && (r[1] !== 0 && (a[0] = a[1], d = dt(f, t, r, o, void 0, d), r = [0, 0, 0, 0]), a[2] = n)) : g.type === "tableCellDivider" && (i ? i = !1 : (r[1] !== 0 && (a[0] = a[1], d = dt(f, t, r, o, void 0, d)), r = a, a = [r[1], n, 0, 0])) : g.type === "tableHead" ? (l = !0, u = n) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (u = n, r[1] !== 0 ? (a[0] = a[1], d = dt(f, t, r, o, n, d)) : a[1] !== 0 && (d = dt(f, t, a, o, n, d)), o = 0) : o && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") && (a[3] = n) } for (u !== 0 && ii(f, t, u, s, c), f.consume(t.events), n = -1; ++n < t.events.length;) { const h = t.events[n]; h[0] === "enter" && h[1].type === "table" && (h[1]._align = nd(t.events, n)) } return e } function dt(e, t, n, i, o, r) { const a = i === 1 ? "tableHeader" : i === 2 ? "tableDelimiter" : "tableData", l = "tableContent"; n[0] !== 0 && (r.end = Object.assign({}, Ne(t.events, n[0])), e.add(n[0], 0, [["exit", r, t]])); const u = Ne(t.events, n[1]); if (r = { type: a, start: Object.assign({}, u), end: Object.assign({}, u) }, e.add(n[1], 0, [["enter", r, t]]), n[2] !== 0) { const s = Ne(t.events, n[2]), c = Ne(t.events, n[3]), d = { type: l, start: Object.assign({}, s), end: Object.assign({}, c) }; if (e.add(n[2], 0, [["enter", d, t]]), i !== 2) { const f = t.events[n[2]], h = t.events[n[3]]; if (f[1].end = Object.assign({}, h[1].end), f[1].type = "chunkText", f[1].contentType = "text", n[3] > n[2] + 1) { const g = n[2] + 1, k = n[3] - n[2] - 1; e.add(g, k, []) } } e.add(n[3] + 1, 0, [["exit", d, t]]) } return o !== void 0 && (r.end = Object.assign({}, Ne(t.events, o)), e.add(o, 0, [["exit", r, t]]), r = void 0), r } function ii(e, t, n, i, o) { const r = [], a = Ne(t.events, n); o && (o.end = Object.assign({}, a), r.push(["exit", o, t])), i.end = Object.assign({}, a), r.push(["exit", i, t]), e.add(n + 1, 0, r) } function Ne(e, t) { const n = e[t], i = n[0] === "enter" ? "start" : "end"; return n[1][i] } const ad = { name: "tasklistCheck", tokenize: sd }; function ld() { return { text: { 91: ad } } } function sd(e, t, n) { const i = this; return o; function o(u) { return i.previous !== null || !i._gfmTasklistFirstContentOfListItem ? n(u) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), r) } function r(u) { return Q(u) ? (e.enter("taskListCheckValueUnchecked"), e.consume(u), e.exit("taskListCheckValueUnchecked"), a) : u === 88 || u === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(u), e.exit("taskListCheckValueChecked"), a) : n(u) } function a(u) { return u === 93 ? (e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), l) : n(u) } function l(u) { return B(u) ? t(u) : j(u) ? e.check({ tokenize: ud }, t, n)(u) : n(u) } } function ud(e, t, n) { return q(e, i, "whitespace"); function i(o) { return o === null ? n(o) : t(o) } } function cd(e) { return Ii([_c(), Wc(), Zc(e), id(), ld()]) } const dd = {}; function ri(e) { const t = this, n = e || dd, i = t.data(), o = i.micromarkExtensions || (i.micromarkExtensions = []), r = i.fromMarkdownExtensions || (i.fromMarkdownExtensions = []), a = i.toMarkdownExtensions || (i.toMarkdownExtensions = []); o.push(cd(n)), r.push(Fc()), a.push(Dc(n)) } const kt = { "#c1f3bd": "#adeea8", "#d3bdf3": "#bfa8e6", "#f3cbbd": "#e7b2a1", "#bdd7f3": "#9bc1e6", "#f3f0bd": "#e6de9c" }; class fr { debounceTime; pollInterval; onStop; onMove; lastStoppedX; lastStoppedY; lastCheckedX; lastCheckedY; moveTimer = null; pollTimer = null; isMoving = !1; constructor(t = {}) { this.debounceTime = t.debounceTime ?? 300, this.pollInterval = t.pollInterval ?? 100, this.onStop = t.onStop ?? (() => { }), this.onMove = t.onMove, this.lastStoppedX = window.screenX, this.lastStoppedY = window.screenY, this.lastCheckedX = window.screenX, this.lastCheckedY = window.screenY, this.start() } start() { this.pollTimer || (this.pollTimer = setInterval(() => { this.check() }, this.pollInterval)) } stop() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null), this.moveTimer && (clearTimeout(this.moveTimer), this.moveTimer = null) } check() { const t = window.screenX, n = window.screenY; if (t !== this.lastCheckedX || n !== this.lastCheckedY) { const i = { x: t, y: n }; this.lastCheckedX = t, this.lastCheckedY = n, this.isMoving || (this.isMoving = !0), this.onMove && this.onMove(i), this.moveTimer && clearTimeout(this.moveTimer), this.moveTimer = setTimeout(() => { this.lastStoppedX = t, this.lastStoppedY = n, this.isMoving = !1, this.onStop(i) }, this.debounceTime) } } getCurrentPosition() { return { x: window.screenX, y: window.screenY } } getLastStoppedPosition() { return { x: this.lastStoppedX, y: this.lastStoppedY } } getIsMoving() { return this.isMoving } destroy() { this.stop() } } let an = {}, pr; function Ut(e = {}) { an = { animate: !0, allowClose: !0, overlayClickBehavior: "close", overlayOpacity: .7, smoothScroll: !1, disableActiveInteraction: !1, showProgress: !1, stagePadding: 10, stageRadius: 5, popoverOffset: 10, showButtons: ["next", "previous", "close"], disableButtons: [], overlayColor: "#000", ...e } } function D(e) { return e ? an[e] : an } function hd(e) { pr = e } function pe() { return pr } let wt = {}; function ht(e, t) { wt[e] = t } function Oe(e) { var t; (t = wt[e]) == null || t.call(wt) } function fd() { wt = {} } function ft(e, t, n, i) { return (e /= i / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t } function mr(e) { const t = 'a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="radio"]:not([disabled]), input[type="checkbox"]:not([disabled]), select:not([disabled])'; return e.flatMap(n => { const i = n.matches(t), o = Array.from(n.querySelectorAll(t)); return [...i ? [n] : [], ...o] }).filter(n => getComputedStyle(n).pointerEvents !== "none" && gd(n)) } function gr(e) { if (!e || md(e)) return; const t = D("smoothScroll"), n = e.offsetHeight > window.innerHeight; e.scrollIntoView({ behavior: !t || pd(e) ? "auto" : "smooth", inline: "center", block: n ? "start" : "center" }) } function pd(e) { if (!e || !e.parentElement) return; const t = e.parentElement; return t.scrollHeight > t.clientHeight } function md(e) { const t = e.getBoundingClientRect(); return t.top >= 0 && t.left >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight) && t.right <= (window.innerWidth || document.documentElement.clientWidth) } function gd(e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) } let xt = {}; function te(e, t) { xt[e] = t } function z(e) { return e ? xt[e] : xt } function oi() { xt = {} } function bd(e, t, n, i) { let o = z("__activeStagePosition"); const r = o || n.getBoundingClientRect(), a = i.getBoundingClientRect(), l = ft(e, r.x, a.x - r.x, t), u = ft(e, r.y, a.y - r.y, t), s = ft(e, r.width, a.width - r.width, t), c = ft(e, r.height, a.height - r.height, t); o = { x: l, y: u, width: s, height: c }, yr(o), te("__activeStagePosition", o) } function br(e) { if (!e) return; const t = e.getBoundingClientRect(), n = { x: t.x, y: t.y, width: t.width, height: t.height }; te("__activeStagePosition", n), yr(n) } function yd() { const e = z("__activeStagePosition"), t = z("__overlaySvg"); if (!e) return; if (!t) { console.warn("No stage svg found."); return } const n = window.innerWidth, i = window.innerHeight; t.setAttribute("viewBox", `0 0 ${n} ${i}`) } function vd(e) { const t = kd(e); document.body.appendChild(t), wr(t, n => { n.target.tagName === "path" && Oe("overlayClick") }), te("__overlaySvg", t) } function yr(e) { const t = z("__overlaySvg"); if (!t) { vd(e); return } const n = t.firstElementChild; if (n?.tagName !== "path") throw new Error("no path element found in stage svg"); n.setAttribute("d", vr(e)) } function kd(e) { const t = window.innerWidth, n = window.innerHeight, i = document.createElementNS("http://www.w3.org/2000/svg", "svg"); i.classList.add("driver-overlay", "driver-overlay-animated"), i.setAttribute("viewBox", `0 0 ${t} ${n}`), i.setAttribute("xmlSpace", "preserve"), i.setAttribute("xmlnsXlink", "http://www.w3.org/1999/xlink"), i.setAttribute("version", "1.1"), i.setAttribute("preserveAspectRatio", "xMinYMin slice"), i.style.fillRule = "evenodd", i.style.clipRule = "evenodd", i.style.strokeLinejoin = "round", i.style.strokeMiterlimit = "2", i.style.zIndex = "10000", i.style.position = "fixed", i.style.top = "0", i.style.left = "0", i.style.width = "100%", i.style.height = "100%"; const o = document.createElementNS("http://www.w3.org/2000/svg", "path"); return o.setAttribute("d", vr(e)), o.style.fill = D("overlayColor") || "rgb(0,0,0)", o.style.opacity = `${D("overlayOpacity")}`, o.style.pointerEvents = "auto", o.style.cursor = "auto", i.appendChild(o), i } function vr(e) {
    const t = window.innerWidth, n = window.innerHeight, i = D("stagePadding") || 0, o = D("stageRadius") || 0, r = e.width + i * 2, a = e.height + i * 2, l = Math.min(o, r / 2, a / 2), u = Math.floor(Math.max(l, 0)), s = e.x - i + u, c = e.y - i, d = r - u * 2, f = a - u * 2; return `M${t},0L0,0L0,${n}L${t},${n}L${t},0Z
    M${s},${c} h${d} a${u},${u} 0 0 1 ${u},${u} v${f} a${u},${u} 0 0 1 -${u},${u} h-${d} a${u},${u} 0 0 1 -${u},-${u} v-${f} a${u},${u} 0 0 1 ${u},-${u} z`
} function wd() { const e = z("__overlaySvg"); e && e.remove() } function xd() { const e = document.getElementById("driver-dummy-element"); if (e) return e; let t = document.createElement("div"); return t.id = "driver-dummy-element", t.style.width = "0", t.style.height = "0", t.style.pointerEvents = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.top = "50%", t.style.left = "50%", document.body.appendChild(t), t } function ai(e) { const { element: t } = e; let n = typeof t == "function" ? t() : typeof t == "string" ? document.querySelector(t) : t; n || (n = xd()), Sd(n, e) } function Id() { const e = z("__activeElement"), t = z("__activeStep"); e && (br(e), yd(), Ir(e, t)) } function Sd(e, t) { var n; const i = Date.now(), o = z("__activeStep"), r = z("__activeElement") || e, a = !r || r === e, l = e.id === "driver-dummy-element", u = r.id === "driver-dummy-element", s = D("animate"), c = t.onHighlightStarted || D("onHighlightStarted"), d = t?.onHighlighted || D("onHighlighted"), f = o?.onDeselected || D("onDeselected"), h = D(), g = z(); !a && f && f(u ? void 0 : r, o, { config: h, state: g, driver: pe() }), c && c(l ? void 0 : e, t, { config: h, state: g, driver: pe() }); const k = !a && s; let w = !1; Ld(), te("previousStep", o), te("previousElement", r), te("activeStep", t), te("activeElement", e); const y = () => { if (z("__transitionCallback") !== y) return; const S = Date.now() - i, I = 400 - S <= 400 / 2; t.popover && I && !w && k && (li(e, t), w = !0), D("animate") && S < 400 ? bd(S, 400, r, e) : (br(e), d && d(l ? void 0 : e, t, { config: D(), state: z(), driver: pe() }), te("__transitionCallback", void 0), te("__previousStep", o), te("__previousElement", r), te("__activeStep", t), te("__activeElement", e)), window.requestAnimationFrame(y) }; te("__transitionCallback", y), window.requestAnimationFrame(y), gr(e), !k && t.popover && li(e, t), r.classList.remove("driver-active-element", "driver-no-interaction"), r.removeAttribute("aria-haspopup"), r.removeAttribute("aria-expanded"), r.removeAttribute("aria-controls"), ((n = t.disableActiveInteraction) != null ? n : D("disableActiveInteraction")) && e.classList.add("driver-no-interaction"), e.classList.add("driver-active-element"), e.setAttribute("aria-haspopup", "dialog"), e.setAttribute("aria-expanded", "true"), e.setAttribute("aria-controls", "driver-popover-content") } function Cd() { var e; (e = document.getElementById("driver-dummy-element")) == null || e.remove(), document.querySelectorAll(".driver-active-element").forEach(t => { t.classList.remove("driver-active-element", "driver-no-interaction"), t.removeAttribute("aria-haspopup"), t.removeAttribute("aria-expanded"), t.removeAttribute("aria-controls") }) } function ot() { const e = z("__resizeTimeout"); e && window.cancelAnimationFrame(e), te("__resizeTimeout", window.requestAnimationFrame(Id)) } function Ed(e) { var t; if (!z("isInitialized") || !(e.key === "Tab" || e.keyCode === 9)) return; const n = z("__activeElement"), i = (t = z("popover")) == null ? void 0 : t.wrapper, o = mr([...i ? [i] : [], ...n ? [n] : []]), r = o[0], a = o[o.length - 1]; if (e.preventDefault(), e.shiftKey) { const l = o[o.indexOf(document.activeElement) - 1] || a; l?.focus() } else { const l = o[o.indexOf(document.activeElement) + 1] || r; l?.focus() } } function kr(e) { var t; ((t = D("allowKeyboardControl")) == null || t) && (e.key === "Escape" ? Oe("escapePress") : e.key === "ArrowRight" ? Oe("arrowRightPress") : e.key === "ArrowLeft" && Oe("arrowLeftPress")) } function wr(e, t, n) { const i = (o, r) => { const a = o.target; e.contains(a) && ((!n || n(a)) && (o.preventDefault(), o.stopPropagation(), o.stopImmediatePropagation()), r?.(o)) }; document.addEventListener("pointerdown", i, !0), document.addEventListener("mousedown", i, !0), document.addEventListener("pointerup", i, !0), document.addEventListener("mouseup", i, !0), document.addEventListener("click", o => { i(o, t) }, !0) } function Ad() { window.addEventListener("keyup", kr, !1), window.addEventListener("keydown", Ed, !1), window.addEventListener("resize", ot), window.addEventListener("scroll", ot) } function Td() { window.removeEventListener("keyup", kr), window.removeEventListener("resize", ot), window.removeEventListener("scroll", ot) } function Ld() { const e = z("popover"); e && (e.wrapper.style.display = "none") } function li(e, t) { var n, i; let o = z("popover"); o && document.body.removeChild(o.wrapper), o = Fd(), document.body.appendChild(o.wrapper); const { title: r, description: a, showButtons: l, disableButtons: u, showProgress: s, nextBtnText: c = D("nextBtnText") || "Next &rarr;", prevBtnText: d = D("prevBtnText") || "&larr; Previous", progressText: f = D("progressText") || "{current} of {total}" } = t.popover || {}; o.nextButton.innerHTML = c, o.previousButton.innerHTML = d, o.progress.innerHTML = f, r ? (o.title.innerHTML = r, o.title.style.display = "block") : o.title.style.display = "none", a ? (o.description.innerHTML = a, o.description.style.display = "block") : o.description.style.display = "none"; const h = l || D("showButtons"), g = s || D("showProgress") || !1, k = h?.includes("next") || h?.includes("previous") || g; o.closeButton.style.display = h.includes("close") ? "block" : "none", k ? (o.footer.style.display = "flex", o.progress.style.display = g ? "block" : "none", o.nextButton.style.display = h.includes("next") ? "block" : "none", o.previousButton.style.display = h.includes("previous") ? "block" : "none") : o.footer.style.display = "none"; const w = u || D("disableButtons") || []; w != null && w.includes("next") && (o.nextButton.disabled = !0, o.nextButton.classList.add("driver-popover-btn-disabled")), w != null && w.includes("previous") && (o.previousButton.disabled = !0, o.previousButton.classList.add("driver-popover-btn-disabled")), w != null && w.includes("close") && (o.closeButton.disabled = !0, o.closeButton.classList.add("driver-popover-btn-disabled")); const y = o.wrapper; y.style.display = "block", y.style.left = "", y.style.top = "", y.style.bottom = "", y.style.right = "", y.id = "driver-popover-content", y.setAttribute("role", "dialog"), y.setAttribute("aria-labelledby", "driver-popover-title"), y.setAttribute("aria-describedby", "driver-popover-description"); const S = o.arrow; S.className = "driver-popover-arrow"; const I = ((n = t.popover) == null ? void 0 : n.popoverClass) || D("popoverClass") || ""; y.className = `driver-popover ${I}`.trim(), wr(o.wrapper, O => { var K, E, b; const T = O.target, L = ((K = t.popover) == null ? void 0 : K.onNextClick) || D("onNextClick"), R = ((E = t.popover) == null ? void 0 : E.onPrevClick) || D("onPrevClick"), N = ((b = t.popover) == null ? void 0 : b.onCloseClick) || D("onCloseClick"); if (T.closest(".driver-popover-next-btn")) return L ? L(e, t, { config: D(), state: z(), driver: pe() }) : Oe("nextClick"); if (T.closest(".driver-popover-prev-btn")) return R ? R(e, t, { config: D(), state: z(), driver: pe() }) : Oe("prevClick"); if (T.closest(".driver-popover-close-btn")) return N ? N(e, t, { config: D(), state: z(), driver: pe() }) : Oe("closeClick") }, O => !(o != null && o.description.contains(O)) && !(o != null && o.title.contains(O)) && typeof O.className == "string" && O.className.includes("driver-popover")), te("popover", o); const M = ((i = t.popover) == null ? void 0 : i.onPopoverRender) || D("onPopoverRender"); M && M(o, { config: D(), state: z(), driver: pe() }), Ir(e, t), gr(y); const F = e.classList.contains("driver-dummy-element"), v = mr([y, ...F ? [] : [e]]); v.length > 0 && v[0].focus() } function xr() { const e = z("popover"); if (!(e != null && e.wrapper)) return; const t = e.wrapper.getBoundingClientRect(), n = D("stagePadding") || 0, i = D("popoverOffset") || 0; return { width: t.width + n + i, height: t.height + n + i, realWidth: t.width, realHeight: t.height } } function si(e, t) { const { elementDimensions: n, popoverDimensions: i, popoverPadding: o, popoverArrowDimensions: r } = t; return e === "start" ? Math.max(Math.min(n.top - o, window.innerHeight - i.realHeight - r.width), r.width) : e === "end" ? Math.max(Math.min(n.top - i?.realHeight + n.height + o, window.innerHeight - i?.realHeight - r.width), r.width) : e === "center" ? Math.max(Math.min(n.top + n.height / 2 - i?.realHeight / 2, window.innerHeight - i?.realHeight - r.width), r.width) : 0 } function ui(e, t) { const { elementDimensions: n, popoverDimensions: i, popoverPadding: o, popoverArrowDimensions: r } = t; return e === "start" ? Math.max(Math.min(n.left - o, window.innerWidth - i.realWidth - r.width), r.width) : e === "end" ? Math.max(Math.min(n.left - i?.realWidth + n.width + o, window.innerWidth - i?.realWidth - r.width), r.width) : e === "center" ? Math.max(Math.min(n.left + n.width / 2 - i?.realWidth / 2, window.innerWidth - i?.realWidth - r.width), r.width) : 0 } function Ir(e, t) { const n = z("popover"); if (!n) return; const { align: i = "start", side: o = "left" } = t?.popover || {}, r = i, a = e.id === "driver-dummy-element" ? "over" : o, l = D("stagePadding") || 0, u = xr(), s = n.arrow.getBoundingClientRect(), c = e.getBoundingClientRect(), d = c.top - u.height; let f = d >= 0; const h = window.innerHeight - (c.bottom + u.height); let g = h >= 0; const k = c.left - u.width; let w = k >= 0; const y = window.innerWidth - (c.right + u.width); let S = y >= 0; const I = !f && !g && !w && !S; let M = a; if (a === "top" && f ? S = w = g = !1 : a === "bottom" && g ? S = w = f = !1 : a === "left" && w ? S = f = g = !1 : a === "right" && S && (w = f = g = !1), a === "over") { const F = window.innerWidth / 2 - u.realWidth / 2, v = window.innerHeight / 2 - u.realHeight / 2; n.wrapper.style.left = `${F}px`, n.wrapper.style.right = "auto", n.wrapper.style.top = `${v}px`, n.wrapper.style.bottom = "auto" } else if (I) { const F = window.innerWidth / 2 - u?.realWidth / 2, v = 10; n.wrapper.style.left = `${F}px`, n.wrapper.style.right = "auto", n.wrapper.style.bottom = `${v}px`, n.wrapper.style.top = "auto" } else if (w) { const F = Math.min(k, window.innerWidth - u?.realWidth - s.width), v = si(r, { elementDimensions: c, popoverDimensions: u, popoverPadding: l, popoverArrowDimensions: s }); n.wrapper.style.left = `${F}px`, n.wrapper.style.top = `${v}px`, n.wrapper.style.bottom = "auto", n.wrapper.style.right = "auto", M = "left" } else if (S) { const F = Math.min(y, window.innerWidth - u?.realWidth - s.width), v = si(r, { elementDimensions: c, popoverDimensions: u, popoverPadding: l, popoverArrowDimensions: s }); n.wrapper.style.right = `${F}px`, n.wrapper.style.top = `${v}px`, n.wrapper.style.bottom = "auto", n.wrapper.style.left = "auto", M = "right" } else if (f) { const F = Math.min(d, window.innerHeight - u.realHeight - s.width); let v = ui(r, { elementDimensions: c, popoverDimensions: u, popoverPadding: l, popoverArrowDimensions: s }); n.wrapper.style.top = `${F}px`, n.wrapper.style.left = `${v}px`, n.wrapper.style.bottom = "auto", n.wrapper.style.right = "auto", M = "top" } else if (g) { const F = Math.min(h, window.innerHeight - u?.realHeight - s.width); let v = ui(r, { elementDimensions: c, popoverDimensions: u, popoverPadding: l, popoverArrowDimensions: s }); n.wrapper.style.left = `${v}px`, n.wrapper.style.bottom = `${F}px`, n.wrapper.style.top = "auto", n.wrapper.style.right = "auto", M = "bottom" } I ? n.arrow.classList.add("driver-popover-arrow-none") : Pd(r, M, e) } function Pd(e, t, n) { const i = z("popover"); if (!i) return; const o = n.getBoundingClientRect(), r = xr(), a = i.arrow, l = r.width, u = window.innerWidth, s = o.width, c = o.left, d = r.height, f = window.innerHeight, h = o.top, g = o.height; a.className = "driver-popover-arrow"; let k = t, w = e; if (t === "top" ? (c + s <= 0 ? (k = "right", w = "end") : c + s - l <= 0 && (k = "top", w = "start"), c >= u ? (k = "left", w = "end") : c + l >= u && (k = "top", w = "end")) : t === "bottom" ? (c + s <= 0 ? (k = "right", w = "start") : c + s - l <= 0 && (k = "bottom", w = "start"), c >= u ? (k = "left", w = "start") : c + l >= u && (k = "bottom", w = "end")) : t === "left" ? (h + g <= 0 ? (k = "bottom", w = "end") : h + g - d <= 0 && (k = "left", w = "start"), h >= f ? (k = "top", w = "end") : h + d >= f && (k = "left", w = "end")) : t === "right" && (h + g <= 0 ? (k = "bottom", w = "start") : h + g - d <= 0 && (k = "right", w = "start"), h >= f ? (k = "top", w = "start") : h + d >= f && (k = "right", w = "end")), !k) a.classList.add("driver-popover-arrow-none"); else { a.classList.add(`driver-popover-arrow-side-${k}`), a.classList.add(`driver-popover-arrow-align-${w}`); const y = n.getBoundingClientRect(), S = a.getBoundingClientRect(), I = D("stagePadding") || 0, M = y.left - I < window.innerWidth && y.right + I > 0 && y.top - I < window.innerHeight && y.bottom + I > 0; t === "bottom" && M && (S.x > y.x && S.x + S.width < y.x + y.width ? i.wrapper.style.transform = "translateY(0)" : (a.classList.remove(`driver-popover-arrow-align-${w}`), a.classList.add("driver-popover-arrow-none"), i.wrapper.style.transform = `translateY(-${I / 2}px)`)) } } function Fd() { const e = document.createElement("div"); e.classList.add("driver-popover"); const t = document.createElement("div"); t.classList.add("driver-popover-arrow"); const n = document.createElement("header"); n.id = "driver-popover-title", n.classList.add("driver-popover-title"), n.style.display = "none", n.innerText = "Popover Title"; const i = document.createElement("div"); i.id = "driver-popover-description", i.classList.add("driver-popover-description"), i.style.display = "none", i.innerText = "Popover description is here"; const o = document.createElement("button"); o.type = "button", o.classList.add("driver-popover-close-btn"), o.setAttribute("aria-label", "Close"), o.innerHTML = "&times;"; const r = document.createElement("footer"); r.classList.add("driver-popover-footer"); const a = document.createElement("span"); a.classList.add("driver-popover-progress-text"), a.innerText = ""; const l = document.createElement("span"); l.classList.add("driver-popover-navigation-btns"); const u = document.createElement("button"); u.type = "button", u.classList.add("driver-popover-prev-btn"), u.innerHTML = "&larr; Previous"; const s = document.createElement("button"); return s.type = "button", s.classList.add("driver-popover-next-btn"), s.innerHTML = "Next &rarr;", l.appendChild(u), l.appendChild(s), r.appendChild(a), r.appendChild(l), e.appendChild(o), e.appendChild(t), e.appendChild(n), e.appendChild(i), e.appendChild(r), { wrapper: e, arrow: t, title: n, description: i, footer: r, previousButton: u, nextButton: s, closeButton: o, footerButtons: l, progress: a } } function Dd() { var e; const t = z("popover"); t && ((e = t.wrapper.parentElement) == null || e.removeChild(t.wrapper)) } function zd(e = {}) { Ut(e); function t() { D("allowClose") && c() } function n() { const f = D("overlayClickBehavior"); if (D("allowClose") && f === "close") { c(); return } f === "nextStep" && i() } function i() { const f = z("activeIndex"), h = D("steps") || []; if (typeof f > "u") return; const g = f + 1; h[g] ? s(g) : c() } function o() { const f = z("activeIndex"), h = D("steps") || []; if (typeof f > "u") return; const g = f - 1; h[g] ? s(g) : c() } function r(f) { (D("steps") || [])[f] ? s(f) : c() } function a() { var f; if (z("__transitionCallback")) return; const h = z("activeIndex"), g = z("__activeStep"), k = z("__activeElement"); if (typeof h > "u" || typeof g > "u" || typeof z("activeIndex") > "u") return; const w = ((f = g.popover) == null ? void 0 : f.onPrevClick) || D("onPrevClick"); if (w) return w(k, g, { config: D(), state: z(), driver: pe() }); o() } function l() { var f; if (z("__transitionCallback")) return; const h = z("activeIndex"), g = z("__activeStep"), k = z("__activeElement"); if (typeof h > "u" || typeof g > "u") return; const w = ((f = g.popover) == null ? void 0 : f.onNextClick) || D("onNextClick"); if (w) return w(k, g, { config: D(), state: z(), driver: pe() }); i() } function u() { z("isInitialized") || (te("isInitialized", !0), document.body.classList.add("driver-active", D("animate") ? "driver-fade" : "driver-simple"), Ad(), ht("overlayClick", n), ht("escapePress", t), ht("arrowLeftPress", a), ht("arrowRightPress", l)) } function s(f = 0) { var h, g, k, w, y, S, I, M; const F = D("steps"); if (!F) { console.error("No steps to drive through"), c(); return } if (!F[f]) { c(); return } te("__activeOnDestroyed", document.activeElement), te("activeIndex", f); const v = F[f], O = F[f + 1], K = F[f - 1], E = ((h = v.popover) == null ? void 0 : h.doneBtnText) || D("doneBtnText") || "Done", b = D("allowClose"), T = typeof ((g = v.popover) == null ? void 0 : g.showProgress) < "u" ? (k = v.popover) == null ? void 0 : k.showProgress : D("showProgress"), L = (((w = v.popover) == null ? void 0 : w.progressText) || D("progressText") || "{{current}} of {{total}}").replace("{{current}}", `${f + 1}`).replace("{{total}}", `${F.length}`), R = ((y = v.popover) == null ? void 0 : y.showButtons) || D("showButtons"), N = ["next", "previous", ...b ? ["close"] : []].filter(_ => !(R != null && R.length) || R.includes(_)), V = ((S = v.popover) == null ? void 0 : S.onNextClick) || D("onNextClick"), C = ((I = v.popover) == null ? void 0 : I.onPrevClick) || D("onPrevClick"), P = ((M = v.popover) == null ? void 0 : M.onCloseClick) || D("onCloseClick"); ai({ ...v, popover: { showButtons: N, nextBtnText: O ? void 0 : E, disableButtons: [...K ? [] : ["previous"]], showProgress: T, progressText: L, onNextClick: V || (() => { O ? s(f + 1) : c() }), onPrevClick: C || (() => { s(f - 1) }), onCloseClick: P || (() => { c() }), ...v?.popover || {} } }) } function c(f = !0) { const h = z("__activeElement"), g = z("__activeStep"), k = z("__activeOnDestroyed"), w = D("onDestroyStarted"); if (f && w) { const I = !h || h?.id === "driver-dummy-element"; w(I ? void 0 : h, g, { config: D(), state: z(), driver: pe() }); return } const y = g?.onDeselected || D("onDeselected"), S = D("onDestroyed"); if (document.body.classList.remove("driver-active", "driver-fade", "driver-simple"), Td(), Dd(), Cd(), wd(), fd(), oi(), h && g) { const I = h.id === "driver-dummy-element"; y && y(I ? void 0 : h, g, { config: D(), state: z(), driver: pe() }), S && S(I ? void 0 : h, g, { config: D(), state: z(), driver: pe() }) } k && k.focus() } const d = { isActive: () => z("isInitialized") || !1, refresh: ot, drive: (f = 0) => { u(), s(f) }, setConfig: Ut, setSteps: f => { oi(), Ut({ ...D(), steps: f }) }, getConfig: D, getState: z, getActiveIndex: () => z("activeIndex"), isFirstStep: () => z("activeIndex") === 0, isLastStep: () => { const f = D("steps") || [], h = z("activeIndex"); return h !== void 0 && h === f.length - 1 }, getActiveStep: () => z("activeStep"), getActiveElement: () => z("activeElement"), getPreviousElement: () => z("previousElement"), getPreviousStep: () => z("previousStep"), moveNext: i, movePrevious: o, moveTo: r, hasNextStep: () => { const f = D("steps") || [], h = z("activeIndex"); return h !== void 0 && !!f[h + 1] }, hasPreviousStep: () => { const f = D("steps") || [], h = z("activeIndex"); return h !== void 0 && !!f[h - 1] }, highlight: f => { u(), ai({ ...f, popover: f.popover ? { showButtons: [], showProgress: !1, progressText: "", ...f.popover } : void 0 }) }, destroy: () => { c(!1) } }; return hd(d), d } const Md = { id: "noteView", class: "main", scroll: "no" }, _d = at({ __name: "note-view", setup(e) { const t = ae(null), n = ae(null); let i = null, o = null; const r = ae(null), a = Ke({ opacity: 1 }), l = Ke({ opacity: 1 }), u = Ke({ textContent: "", background: "#c1f3bd", headerBackground: "#adeea8", isEdit: !1, isAlwaysOnTop: !0 }), s = ae(!1), c = zd({ popoverClass: "driverjs-theme", showProgress: !0, showButtons: ["next", "previous", "close"], nextBtnText: "下一个", prevBtnText: "上一个", doneBtnText: "完成", disableActiveInteraction: !0, steps: [{ element: "#windowHeader", popover: { title: "移动便签", description: "长按顶部栏可拖动便签" } }, { element: "#noteBody", popover: { title: "快速编辑", description: "双击空白处进入编辑模式" } }, { element: "#moreBtn", popover: { title: "修改背景", description: "可设置背景色和透明度" } }, { element: "#noteView", popover: { title: "修改尺寸", description: "鼠标放置便签边缘可拖动修改尺寸" } }], onDestroyStarted: () => { console.log("引导开始销毁"), setTimeout(() => { c.isActive && (console.log("强制销毁"), c.destroy()) }, 100) }, onDestroyed: () => { console.log("引导已销毁") }, onHighlightStarted: E => { console.log("开始高亮元素:", E) } }), d = nt(() => { const E = s.value ? l.opacity : a.opacity; return bt(u.background, E) }), f = nt(() => { const E = s.value ? l.opacity : a.opacity; return bt(u.headerBackground, E) }); sn(() => { const E = un(); if (E.id) { const b = oe.getOneData(E.id); b && (r.value = b.data, u.textContent = b.data.text, u.background = b.data.background, u.headerBackground = kt[u.background], a.opacity = b.data.backgroundOpacity || 1) } else ztools.dbStorage.getItem("needDriver") === !0 && (ztools.dbStorage.setItem("needDriver", !1), c.drive()); E.isEdit === "true" ? (u.isEdit = !0, S()) : I(), o = new fr({ debounceTime: 300, pollInterval: 250, onStop: b => { console.log("窗口停止移动:", b), w() } }) }), mi(() => { o?.destroy() }); function h() { a.opacity = l.opacity, s.value = !1, r.value && (r.value.backgroundOpacity = a.opacity, oe.updateData(Je(r.value))) } function g() { l.opacity = a.opacity, s.value = !0 } async function k() { await w(), o?.destroy(), window.close() } async function w() { if (r.value && r.value.id) { const E = await window.customFloatAPI?.getWinInfoDirect(); E && (r.value.winWidth = E.outerWidth, r.value.winHeight = E.outerHeight, r.value.winX = E.x, r.value.winY = E.y), oe.updateData(Je(r.value)) } } function y(E) { console.log("changeAlwaysOnTop", E), window.customFloatAPI?.setAlwaysOnTop(E), r.value && (r.value.alwaysOnTop = E, oe.updateData(JSON.parse(JSON.stringify(r.value)))), setTimeout(() => { u.isAlwaysOnTop = E }, 300) } function S() { be(() => { i = new An("vditor", { cdn: "./vditor", height: "100%", value: u.textContent, mode: "wysiwyg", toolbar: ["headings", "bold", "strike", "list", "ordered-list", "check"], placeholder: "请输入内容...", cache: { enable: !1 }, after: () => { console.log("Vditor初始化完成") } }) }) } function I() { be(() => { n.value && An.preview(n.value, u.textContent, { cdn: "./vditor", mode: "light", hljs: { enable: !0, style: "github" }, after() { console.log("Vditor预览完成"), Array.from(n.value.querySelectorAll('input[type="checkbox"]')).forEach((b, T) => { b.disabled = !1, b.addEventListener("change", R => { const N = R.target.checked; M(T, N) }); const L = b.nextSibling; if (L && L.nodeType === Node.TEXT_NODE && L.textContent && L.textContent.trim() !== "") { const R = document.createElement("span"); R.textContent = L.textContent, b.parentNode?.insertBefore(R, L), b.parentNode?.removeChild(L) } }) } }) }) } function M(E, b) { const T = Jn().use(Oi).use(ri).parse(u.textContent); let L = 0; ji(T, "listItem", N => { typeof N.checked == "boolean" && (L === E && (N.checked = b), L++) }); const R = Jn().use(ri).use(er, { bullet: "-", handlers: { text: (N, V, C) => N.value } }).stringify(T); u.textContent = R, I(), v() } function F() { u.isEdit = !1, u.textContent = i?.getValue() || "", I(), v() } async function v() { if (u.textContent.length !== 0) { const E = await window.customFloatAPI?.getWinInfoDirect(); if (r.value) { const b = { id: r.value.id, text: u.textContent, updatedAt: he().format("YYYY-MM-DD HH:mm:ss"), update: he().valueOf(), createdAt: r.value.createdAt, create: r.value.create, background: u.background, backgroundOpacity: a.opacity, alwaysOnTop: u.isAlwaysOnTop, winWidth: E ? E.outerWidth : 310, winHeight: E ? E.outerHeight : 330, winX: E ? E.x : 0, winY: E ? E.y : 0, type: "normal" }; oe.updateData(b), r.value = b } else { const b = { id: `note-${Ge()}`, text: u.textContent, background: u.background, updatedAt: he().format("YYYY-MM-DD HH:mm:ss"), createdAt: he().format("YYYY-MM-DD HH:mm:ss"), update: he().valueOf(), create: he().valueOf(), backgroundOpacity: a.opacity, alwaysOnTop: u.isAlwaysOnTop, winWidth: E ? E.outerWidth : 310, winHeight: E ? E.outerHeight : 330, winX: E ? E.x : 0, winY: E ? E.y : 0, type: "normal" }; oe.insertData(b), r.value = b } window.customFloatAPI?.sendToMain("refresh") } } function O() { u.isEdit || (u.isEdit = !0, S()) } function K(E) { u.background = E, u.headerBackground = kt[E], r.value && (r.value.background = u.background, oe.updateData(Je(r.value))), window.customFloatAPI?.sendToMain("refresh") } return (E, b) => (H(), Y("div", Md, [ke(vi, { isEditing: u.isEdit, background: f.value, isAlwaysOnTop: u.isAlwaysOnTop, showEditSaveMenu: !0, onEdit: O, onSave: F, onClose: k, onChangeBg: K, onOpenOpacitySetting: g, onChangeAlwaysOnTop: y }, null, 8, ["isEditing", "background", "isAlwaysOnTop"]), J("div", { id: "noteBody", class: "body", style: it({ background: d.value }), onDblclick: O }, [u.isEdit ? ee("", !0) : (H(), Y("div", { key: 0, ref_key: "vditorPreviewRef", ref: n, class: "vditor-box" }, null, 512)), u.isEdit ? (H(), Y("div", { key: 1, id: "vditor", ref_key: "vditorEditRef", ref: t, class: "vditor-box" }, null, 512)) : ee("", !0)], 36), ke(wi, { visible: s.value, "onUpdate:visible": b[0] || (b[0] = T => s.value = T), opacity: l.opacity, "onUpdate:opacity": b[1] || (b[1] = T => l.opacity = T), onConfirm: h }, null, 8, ["visible", "opacity"])])) } }), Bd = It(_d, [["__scopeId", "data-v-1ed061db"]]), Od = { id: "noteView", class: "main", scroll: "no" }, Rd = ["onDblclick"], $d = { class: "todo-item-inner" }, Hd = ["onUpdate:modelValue"], Vd = ["id", "onUpdate:modelValue", "onKeydown"], Nd = ["id"], jd = at({ __name: "todo-view", setup(e) { let t = null; const n = ae(null), i = ae(""), o = Ke({ opacity: 1 }), r = Ke({ opacity: 1 }), a = Ke({ background: "#c1f3bd", headerBackground: "#adeea8", isEdit: !1, isAlwaysOnTop: !0 }), l = ae([]), u = ae(!1), s = ae(null), c = ae(new Map), d = nt(() => { const C = u.value ? r.opacity : o.opacity; return bt(a.background, C) }), f = nt(() => { const C = u.value ? r.opacity : o.opacity; return bt(a.headerBackground, C) }); sn(() => { const C = un(); if (C.id) { const P = oe.getOneData(C.id); P && (n.value = P.data, a.background = P.data.background, a.headerBackground = kt[a.background], o.opacity = P.data.backgroundOpacity || 1, i.value = P.data.title || "", l.value = P.data.todoList || [], a.isAlwaysOnTop = P.data.alwaysOnTop === void 0 ? !0 : P.data.alwaysOnTop) } t = new fr({ debounceTime: 300, pollInterval: 250, onStop: P => { console.log("窗口停止移动:", P), T() } }) }), mi(() => { t?.destroy() }); function h() { k() } function g() { console.log("handleTodoInputBlur"), k() } function k() { setTimeout(() => { const C = document.activeElement; Array.from(c.value.values()).some(Z => Z.id === C?.id) || (console.log("todo all blur"), s.value && s.value !== C && (console.log("title also blur"), K())) }, 50) } function w(C, P) { C instanceof HTMLInputElement ? c.value.set(P, C) : c.value.delete(P) } function y(C, P) { switch (C.key) { case "Enter": C.preventDefault(), I(P); break; case "ArrowUp": C.preventDefault(), F("up", P); break; case "ArrowDown": C.preventDefault(), F("down", P); break; case "Backspace": S(C, P); break } } function S(C, P) { const _ = l.value.findIndex(p => p.id === P); if (_ === -1) return; if (l.value[_].text === "" && _ > 0) { C.preventDefault(); const p = l.value[_ - 1]; l.value.splice(_, 1), be(() => { const X = c.value.get(p.id); X?.focus(); const de = p.text.length; X?.setSelectionRange(de, de) }) } } function I(C) { const P = l.value.findIndex(X => X.id === C); if (P === -1) return; const _ = l.value[P], Z = _.text.trim(); if (!Z) return; _.text = Z; const p = { id: Ge(), text: "", completed: !1 }; l.value.splice(P + 1, 0, p), be(() => { const X = c.value.get(p.id); X?.focus(), X?.setSelectionRange(0, 0) }) } function M() { if (l.value.length === 0) { const C = { id: Ge(), text: "", completed: !1 }; l.value.push(C), be(() => { c.value.get(C.id)?.focus() }) } else { const C = l.value[0]; be(() => { const P = c.value.get(C.id); P?.focus(); const _ = C.text.length; P?.setSelectionRange(_, _) }) } } function F(C, P) { const _ = l.value.findIndex(X => X.id === P); if (_ === -1) return; let Z; if (C === "up" && _ > 0) Z = _ - 1; else if (C === "down" && _ < l.value.length - 1) Z = _ + 1; else return; const p = l.value[Z]; be(() => { c.value.get(p.id)?.focus() }) } function v(C) { if (console.log("startEditList"), !a.isEdit) if (a.isEdit = !0, l.value.length === 0) { const P = { id: Ge(), text: "", completed: !1 }; l.value.push(P), be(() => { c.value.get(P.id)?.focus() }) } else if (C) { const P = l.value.find(_ => _.id === C); P && be(() => { c.value.get(P.id)?.focus() }) } else { const P = l.value[l.value.length - 1]; be(() => { c.value.get(P.id)?.focus() }) } } function O() { a.isEdit = !0, be(() => { s.value?.focus() }) } async function K() { console.log("onSave"), a.isEdit = !1, l.value = l.value.filter(P => P.text.trim() !== ""); const C = await window.customFloatAPI?.getWinInfoDirect(); if (n.value) n.value.title = i.value, n.value.todoList = l.value, n.value.alwaysOnTop = a.isAlwaysOnTop, n.value.winWidth = C ? C.outerWidth : 310, n.value.winHeight = C ? C.outerHeight : 330, n.value.winX = C ? C.x : 0, n.value.winY = C ? C.y : 0, n.value.updatedAt = he().format("YYYY-MM-DD HH:mm:ss"), n.value.update = he().valueOf(), oe.updateData(JSON.parse(JSON.stringify(n.value))); else { const P = { id: `note-${Ge()}`, text: "", background: a.background, updatedAt: he().format("YYYY-MM-DD HH:mm:ss"), createdAt: he().format("YYYY-MM-DD HH:mm:ss"), update: he().valueOf(), create: he().valueOf(), backgroundOpacity: o.opacity, alwaysOnTop: a.isAlwaysOnTop, winWidth: C ? C.outerWidth : 310, winHeight: C ? C.outerHeight : 330, winX: C ? C.x : 0, winY: C ? C.y : 0, type: "todo", title: Je(i.value), todoList: Je(l.value) }; oe.insertData(JSON.parse(JSON.stringify(P))), n.value = P } window.customFloatAPI?.sendToMain("refresh") } function E() { K() } async function b() { await T(), t?.destroy(), window.close() } async function T() { if (n.value && n.value.id) { const C = await window.customFloatAPI?.getWinInfoDirect(); C && (n.value.winWidth = C.outerWidth, n.value.winHeight = C.outerHeight, n.value.winX = C.x, n.value.winY = C.y), oe.updateData(JSON.parse(JSON.stringify(n.value))) } } function L(C) { console.log("changeAlwaysOnTop", C), window.customFloatAPI?.setAlwaysOnTop(C), n.value && (n.value.alwaysOnTop = C, oe.updateData(JSON.parse(JSON.stringify(n.value)))), setTimeout(() => { a.isAlwaysOnTop = C }, 300) } function R(C) { a.background = C, a.headerBackground = kt[C], n.value && (n.value.background = a.background, oe.updateData(JSON.parse(JSON.stringify(n.value)))), window.customFloatAPI?.sendToMain("refresh"), console.log("onChangeBackground", C) } function N() { r.opacity = o.opacity, u.value = !0 } function V() { o.opacity = r.opacity, u.value = !1, n.value && (n.value.backgroundOpacity = o.opacity, oe.updateData(JSON.parse(JSON.stringify(n.value)))) } return (C, P) => (H(), Y(Xe, null, [J("div", Od, [ke(vi, { isEditing: a.isEdit, background: f.value, isAlwaysOnTop: a.isAlwaysOnTop, showEditSaveMenu: !1, onEdit: v, onSave: K, onClose: b, onChangeBg: R, onOpenOpacitySetting: N, onChangeAlwaysOnTop: L }, null, 8, ["isEditing", "background", "isAlwaysOnTop"]), J("div", { id: "todoBody", class: "body", style: it({ background: d.value }) }, [J("div", { class: "todo-title", onDblclick: O }, [a.isEdit ? pt((H(), Y("input", { key: 1, ref_key: "titleInputRef", ref: s, class: "title-input", "onUpdate:modelValue": P[0] || (P[0] = _ => i.value = _), type: "text", placeholder: "输入标题", onBlur: h, onKeyup: eo(M, ["enter"]) }, null, 544)), [[Tn, i.value]]) : (H(), Y("div", { key: 0, class: "normal", style: it({ opacity: i.value ? 1 : .3 }) }, Be(i.value || "标题"), 5))], 32), J("div", { class: "todo-list", onDblclick: P[1] || (P[1] = _ => v()) }, [(H(!0), Y(Xe, null, hi(l.value, (_, Z) => (H(), Y("div", { class: "todo-item", key: _.id, onDblclick: to(p => v(_.id), ["stop"]) }, [J("div", $d, [pt(J("input", { class: "checkbox", type: "checkbox", "onUpdate:modelValue": p => _.completed = p, onChange: E }, null, 40, Hd), [[no, _.completed]]), a.isEdit ? pt((H(), Y("input", { key: 0, ref_for: !0, ref: p => w(p, _.id), id: "todo_" + _.id, class: "text-input", type: "text", "onUpdate:modelValue": p => _.text = p, onKeydown: p => y(p, _.id), onBlur: g }, null, 40, Vd)), [[Tn, _.text]]) : (H(), Y("div", { key: 1, id: "todo_" + _.id, class: "todo-text" }, Be(_.text), 9, Nd))])], 40, Rd))), 128))], 32)], 4)]), ke(wi, { visible: u.value, "onUpdate:visible": P[2] || (P[2] = _ => u.value = _), opacity: r.opacity, "onUpdate:opacity": P[3] || (P[3] = _ => r.opacity = _), onConfirm: V }, null, 8, ["visible", "opacity"])], 64)) } }), Kd = It(jd, [["__scopeId", "data-v-f232b8c5"]]), Wd = io({ history: ro("./"), routes: [{ path: "/note", name: "note", component: Bd }, { path: "/todo", name: "todo", component: Kd }] }), yn = oo(so); yn.use(Wd); yn.use(ao, { theme: { preset: lo } }); yn.mount("#app");
